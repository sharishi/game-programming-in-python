# Условные инструкции и циклы
### Условные инструкции в Python

**Условные инструкции** позволяют программе выполнять определенные блоки кода в зависимости от выполнения условий. Они являются основой для управления потоком выполнения в Python.

---

### Основные операторы условий:

1. **`if`**: Выполняет блок кода, если условие истинно.
2. **`elif`** (сокращение от *else if*): Проверяет другое условие, если предыдущее ложное.
3. **`else`**: Выполняет блок кода, если все условия выше ложные.

---

### Синтаксис

```python
if условие:
    # блок кода, который выполнится, если условие истинно
elif другое_условие:
    # блок кода, который выполнится, если другое_условие истинно
else:
    # блок кода, который выполнится, если ни одно условие не выполнено
```

---

### Примеры:

#### Простой `if`-блок:
```python
x = 10
if x > 5:
    print("x больше 5")
```

**Вывод**:  
```
x больше 5
```

---

#### Использование `if-elif-else`:
```python
x = 15
if x < 10:
    print("x меньше 10")
elif x == 15:
    print("x равно 15")
else:
    print("x больше 15")
```

**Вывод**:  
```
x равно 15
```

---

#### Вложенные условия:
```python
x = 20
if x > 10:
    if x < 30:
        print("x больше 10, но меньше 30")
```

**Вывод**:  
```
x больше 10, но меньше 30
```

---

### Условные выражения

Python поддерживает **тернарный оператор** — компактную форму записи условия.

#### Пример:
```python
x = 5
result = "положительное" if x > 0 else "отрицательное"
print(result)
```

**Вывод**:  
```
положительное
```

---
### Компактный код с использованием кортежей

В Python можно использовать кортежи для написания компактного кода, заменяющего условные операторы. Такой подход основан на индексации кортежа в зависимости от результата логического выражения.



#### Синтаксис:
```python
(if_test_is_false, if_test_is_true)[test]
```
Где:
- `if_test_is_false` — значение, которое будет выбрано, если `test` равно `False` (или `0`).
- `if_test_is_true` — значение, которое будет выбрано, если `test` равно `True` (или `1`).
- `test` — логическое выражение.



### Пример:

#### Пример 1:
```python
nice = True  # Переменная, определяющая состояние
caract = ("ugly", "nice")[nice]  # Кортеж выбирает значение по индексу
print("The cat is", caract)
```

**Вывод**:
```
The cat is nice
```

#### Пример 2:
```python
nice = False  # Переменная, определяющая состояние
caract = ("ugly", "nice")[nice]  # Индекс 0, так как nice = False
print("The cat is", caract)
```

**Вывод**:
```
The cat is ugly
```


### Объяснение:
1. Логическое значение `True` интерпретируется как `1`, а `False` как `0`.
2. Индексация кортежа `(if_test_is_false, if_test_is_true)[test]` использует этот факт:
   - Если `test = True`, выбирается элемент с индексом `1` (второй).
   - Если `test = False`, выбирается элемент с индексом `0` (первый).


### Преимущества:
- Компактная запись.
- Удобно для случаев с двумя возможными значениями.

### Ограничения:
- Этот подход не рекомендуется для сложных условий, так как он снижает читаемость кода.
- Убедитесь, что `test` всегда принимает значение `True` или `False`. В противном случае результат может быть непредсказуемым.


#### Для лучшей читаемости и гибкости часто предпочтительнее использовать тернарный оператор:
```python
caract = "nice" if nice else "ugly"
print("The cat is", caract)
```

**Вывод**:
```
The cat is nice
```
---

### Операторы сравнения

Операторы сравнения используются для проверки условий:

| Оператор | Описание               | Пример      |
|----------|------------------------|-------------|
| `==`     | Равно                  | `x == y`    |
| `!=`     | Не равно               | `x != y`    |
| `<`      | Меньше                 | `x < y`     |
| `>`      | Больше                 | `x > y`     |
| `<=`     | Меньше или равно       | `x <= y`    |
| `>=`     | Больше или равно       | `x >= y`    |

---

### Логические операторы

Для комбинирования нескольких условий используются **логические операторы**:

| Оператор | Описание                                   | Пример                   |
|----------|-------------------------------------------|--------------------------|
| `and`    | Возвращает `True`, если оба условия истинны | `x > 5 and y < 10`       |
| `or`     | Возвращает `True`, если хотя бы одно условие истинно | `x > 5 or y < 10`        |
| `not`    | Инвертирует условие                       | `not (x > 5)`            |

#### Пример:
```python
x = 10
y = 5
if x > 5 and y < 10:
    print("Оба условия истинны")
```

**Вывод**:  
```
Оба условия истинны
```

---

### Работа с `in` и `not in`

Эти операторы используются для проверки наличия элемента в коллекциях (строки, списки, кортежи, словари).

#### Пример:
```python
fruits = ["яблоко", "банан", "вишня"]
if "яблоко" in fruits:
    print("Яблоко есть в списке")
```

**Вывод**:  
```
Яблоко есть в списке
```

---

### Примеры с вводом данных

```python
age = int(input("Введите ваш возраст: "))

if age < 18:
    print("Вы несовершеннолетний.")
elif age >= 18 and age < 65:
    print("Вы взрослый.")
else:
    print("Вы пенсионер.")
```

**Вывод (в зависимости от ввода)**:  
```
Введите ваш возраст: 25
Вы взрослый.
```

---
### Аналогия Switch…Case в Python

В Python нет встроенного оператора `switch…case`, но есть несколько способов добиться аналогичного поведения, используя `if…elif…else`, словари или функции. Рассмотрим основные подходы.


### 1. Использование `if…elif…else`
Это наиболее очевидный способ обработки различных условий.

#### Пример:
```python
option = int(input("Input the option...[1..3]: "))
if option == 1:
    print("Print")
elif option == 2:
    print("Read")
elif option == 3:
    print("Exit")
else:
    print("Repeat input")
```

### 2. Использование словарей
Словари позволяют сопоставлять ключи с определенными значениями или функциями. Это простой и удобный аналог `switch…case`.

#### Пример:
```python
choices = {
    1: "Print",
    2: "Read",
    3: "Exit"
}

key = int(input("Input the option...[1..3]: "))
result = choices.get(key, "Repeat input")  # Если ключ не найден, используется значение по умолчанию
print(result)
```

### 3. Использование функций внутри словаря
Если необходимо выполнить разные действия для каждой опции, можно хранить функции в словаре.

#### Пример:
```python
def print_action():
    return "You chose to Print"

def read_action():
    return "You chose to Read"

def exit_action():
    return "You chose to Exit"

# Словарь действий
actions = {
    1: print_action,
    2: read_action,
    3: exit_action
}

key = int(input("Input the option...[1..3]: "))
action = actions.get(key, lambda: "Repeat input")  # Лямбда-функция для значения по умолчанию
print(action())  # Вызываем выбранную функцию
```

### 4. Использование функции с возвратом из словаря
Можно создать функцию, которая будет возвращать соответствующее значение из словаря.

#### Пример:
```python
def switch_case(option):
    return {
        1: "Print",
        2: "Read",
        3: "Exit"
    }.get(option, "Repeat input")  # Значение по умолчанию

print(switch_case(2))  # Read
print(switch_case(7))  # Repeat input
```

### Метод `get()` в словарях
Метод `get()` позволяет безопасно извлекать значение по ключу. Если ключ отсутствует, возвращается значение по умолчанию (или `None`, если значение по умолчанию не указано).

#### Синтаксис:
```python
Dict.get(key, default=None)
```

#### Пример:
```python
my_dict = {"a": 1, "b": 2, "c": 3}

print(my_dict.get("b"))         # 2
print(my_dict.get("d"))         # None
print(my_dict.get("d", "N/A"))  # N/A
```
---
### **Конструкция `match…case` в Python**

С выходом Python 3.10 был добавлен оператор `match`, который позволяет использовать структурное сопоставление с образцом (structural pattern matching). Это мощный инструмент для обработки данных различных типов и форм, который упрощает код и делает его более читабельным.



### **Основные особенности конструкции `match…case`**

- **Расширенные возможности:** `match` больше, чем стандартный `switch` в других языках, поскольку поддерживает сопоставление сложных структур данных.
- **Шаблоны:** Конструкция поддерживает последовательности, словари, примитивные типы данных (`int`, `float`, `str` и т.д.), а также экземпляры классов.
- **Улучшение читаемости:** Упрощает обработку данных, заменяя сложные `if…elif…else` конструкции.



### **Синтаксис**

```python
match subject:
    case pattern1:
        # Действия, если pattern1 совпал
    case pattern2:
        # Действия, если pattern2 совпал
    case _:
        # Подстановочный знак (wildcard) для остальных случаев
```


### **Как работает `match…case`**

1. **Сравнение:** Выражение `subject` сравнивается с шаблонами, указанными в `case`.
2. **Приоритет:** Сравнение происходит сверху вниз. Как только найдено совпадение, выполняется соответствующий блок.
3. **Подстановочный знак `_`:** Используется как "случай по умолчанию", если не найдено других совпадений.
4. **Тип данных:** Литералы сравниваются по значению, а синглтоны (`True`, `False`, `None`) — по идентичности.


### **Пример использования**

#### Простой пример
```python
def check_status(code):
    match code:
        case 200:
            return "OK"
        case 404:
            return "Not Found"
        case 500:
            return "Internal Server Error"
        case _:
            return "Unknown Status Code"

print(check_status(200))  # OK
print(check_status(404))  # Not Found
print(check_status(123))  # Unknown Status Code
```

#### Сложные структуры данных
```python
data = {"type": "circle", "radius": 5}

match data:
    case {"type": "circle", "radius": r}:
        print(f"Circle with radius {r}")
    case {"type": "square", "side": s}:
        print(f"Square with side {s}")
    case _:
        print("Unknown shape")
```

#### Сопоставление последовательностей
```python
items = [1, 2, 3]

match items:
    case [1, 2, 3]:
        print("Exact match!")
    case [1, *_]:
        print("Starts with 1")
    case _:
        print("No match")
```

### **Шаблоны в Structural Pattern Matching**

Шаблоны в конструкции `match…case` в Python позволяют задавать условия для сопоставления значений, которые могут быть как простыми, так и сложными. Важно отметить, что шаблоны не только проверяют соответствие значению, но и могут извлекать данные для дальнейшего использования. Рассмотрим основные типы шаблонов.

---

### **1. Простые значения**

### Пример: Сопоставление с единственным значением
```python
match 'a':
    case 'a':
        print("Matched 'a'")
```
Этот шаблон просто сопоставляет строку `'a'` с значением `'a'`. В случае совпадения выполняется код внутри блока `case`.

---

### **2. Сопоставление с коллекциями**

### Пример: Сопоставление с коллекцией значений
```python
match ['a', 'b']:
    case ['a', 'b']:
        print("Matched list ['a', 'b']")
```
Этот шаблон сравнивает коллекцию (список) с точно заданным содержимым.

### Пример: Извлечение значений из коллекции
```python
match ['a', 42]:
    case ['a', value1]:
        print(f"Matched 'a' and extracted value1: {value1}")
```
Здесь происходит сопоставление с коллекцией, состоящей из двух элементов. Второй элемент сохраняется в переменную `value1`.

### Пример: Использование оператора `*` для сбора оставшихся элементов
```python
match ['a', 42, 'b', 56]:
    case ['a', *values]:
        print(f"Matched 'a' and collected remaining values: {values}")
```
В этом примере с помощью `*values` все оставшиеся элементы коллекции после первого сохраняются в переменную `values`. Этот шаблон полезен для работы с коллекциями переменной длины. Важно, что в шаблоне может быть только один элемент с `*`, который собирает все остальные значения.

---

### **3. Использование логических операторов**

### Пример: Использование оператора `|` (OR)
```python
match 'b':
    case 'a' | 'b' | 'c':
        print("Matched 'a', 'b' or 'c'")
```
Оператор `|` позволяет создать шаблон, который совпадает с любым из нескольких значений. В данном случае этот шаблон сопоставляет переменную с одним из трех значений: `'a'`, `'b'` или `'c'`.

### Пример: Использование `|` с извлечением значений
```python
match 'b':
    case ('a' | 'b' | 'c') as letter:
        print(f"Matched '{letter}' and extracted letter.")
```
Здесь также используется оператор `|`, но дополнительно значением будет присвоено имя `letter`, что позволяет работать с этим значением дальше.

---

## **4. Использование подстановочного знака `_`**

### Пример: Сопоставление с коллекцией, начинающейся с определенного элемента
```python
match ['z', 1, 2, 3]:
    case ['z', _]:
        print("Matched collection starting with 'z'")
```
Подстановочный знак `_` используется для обозначения любого значения, которое нас не интересует. В этом примере шаблон совпадает с любыми коллекциями, начинающимися с `'z'`, а оставшиеся элементы игнорируются.

---

### **5. Шаблоны с комбинациями**

### Пример: Сопоставление с кортежем и извлечение значений
```python
match ('a', 5, 'z'):
    case ('a', number, _):
        print(f"Matched 'a' and extracted number: {number}")
```
Здесь кортеж с тремя элементами проверяется, и извлекаются только те значения, которые нас интересуют, а остальные игнорируются с помощью подстановочного знака `_`.


### **Преимущества `match…case`**

- Повышает читаемость кода, упрощая обработку сложных данных.
- Гибкость при работе с последовательностями, словарями и объектами.
- Возможность сопоставления с типами и извлечения данных.

### Полезные советы:
1. **Избегайте избыточных условий**: Проверяйте только то, что необходимо.
2. **Используйте логические операторы для упрощения кода**.
3. **Тестируйте крайние случаи**: Проверьте, как код работает при разных входных данных.

---

# Циклы в Python

Циклы являются одним из важнейших инструментов программирования, так как они позволяют
многократно выполнять определенные блоки кода.
В Python есть два основных типа циклов: **for** и **while**(управляемый подсчетом и
управляемый условием). В этой лекции мы подробно рассмотрим их особенности, синтаксис и примеры использования.


## **1. Цикл `for`**

Цикл `for` используется для перебора элементов в последовательности (например, списка, строки, кортежа) или других итерируемых объектах (например, словарях, множествах). Этот цикл выполняет блок кода для каждого элемента в последовательности.

### **Синтаксис цикла `for`**
```python
for элемент in последовательность:
    # блок кода
```

### **Пример: Перебор элементов в списке**
```python
fruits = ["яблоки", "бананы", "черешня"]
for fruit in fruits:
    print(fruit)
```
Результат:
```
яблоки
бананы
черешня
```

Цикл `for` поочередно перебирает все элементы в списке и выполняет код внутри блока. В переменной `fruit` сохраняется текущий элемент из списка на каждой итерации.

---

### **Цикл `for` с функцией `range`**

Функция `range` генерирует последовательность чисел, которая часто используется для задания диапазона индексов в цикле.

#### **Синтаксис:**
```python
for i in range(start, stop, step):
    # блок кода
```

- `start`: начальное значение (включительно, по умолчанию 0).
- `stop`: конечное значение (не включительно).
- `step`: шаг (по умолчанию 1).

### **Пример: Использование `range` для вывода чисел от 1 до 5**
```python
for i in range(1, 6):
    print(i)
```
Результат:
```
1
2
3
4
5
```

### **Пример: С использованием шага**
```python
for i in range(0, 10, 2):
    print(i)
```
Результат:
```
0
2
4
6
8
```
Здесь цикл перебирает числа от 0 до 9 с шагом 2.

---

## **2. Цикл `while`**

Цикл `while` выполняет блок кода до тех пор, пока условие истинно. Этот цикл обычно используется, когда заранее неизвестно количество итераций, и мы продолжаем цикл до тех пор, пока не будет выполнено некоторое условие.

### **Синтаксис цикла `while`**
```python
while условие:
    # блок кода
```

### **Пример: Цикл с условием**
```python
i = 0
while i < 5:
    print(i)
    i += 1
```
Результат:
```
0
1
2
3
4
```

Цикл продолжает выполняться, пока переменная `i` меньше 5. После каждого выполнения переменная `i` увеличивается на 1.

---

## **3. Управление циклом: `break`, `continue`, `else`**

### **3.1 Оператор `break`**

Оператор `break` используется для немедленного выхода из цикла, независимо от того, выполнено ли условие.

### **Пример: Использование `break` для выхода из цикла**
```python
for i in range(10):
    if i == 5:
        break
    print(i)
```
Результат:
```
0
1
2
3
4
```
Цикл завершится, когда переменная `i` станет равной 5.

### **3.2 Оператор `continue`**

Оператор `continue` пропускает текущую итерацию и продолжает выполнение цикла с следующего шага.

### **Пример: Использование `continue` для пропуска четных чисел**
```python
for i in range(10):
    if i % 2 == 0:
        continue
    print(i)
```
Результат:
```
1
3
5
7
9
```
В этом примере четные числа пропускаются.

### **3.3 Оператор `else`**

Циклы в Python могут завершаться блоком `else`, который выполняется, если цикл завершился нормально (не был прерван с помощью `break`).

### **Пример: Цикл с `else`**
```python
for i in range(3):
    print(i)
else:
    print("Цикл завершен")
```
Результат:
```
0
1
2
Цикл завершен
```
Если цикл не был прерван с помощью `break`, то выполнится блок `else`.



## **4. Вложенные циклы**

Циклы могут быть вложены друг в друга. Внешний цикл выполняет несколько итераций, и для каждой итерации выполняется внутренний цикл.

### **Пример: Вложенные циклы**
```python
for i in range(3):
    for j in range(2):
        print(f"i = {i}, j = {j}")
```
Результат:
```
i = 0, j = 0
i = 0, j = 1
i = 1, j = 0
i = 1, j = 1
i = 2, j = 0
i = 2, j = 1
```
Внешний цикл выполняется три раза, и для каждой итерации внешнего цикла внутренний цикл выполняется дважды.

---

## **1. List Comprehension**

### **Что такое List Comprehension?**

**List Comprehension** — это краткий и выразительный способ создания списков в Python. Вместо использования традиционного цикла `for` для добавления элементов в список, можно создать новый список на основе существующего, применяя фильтрацию и трансформацию элементов с использованием одного выражения.

### **Синтаксис List Comprehension**

```python
[выражение for элемент in итерируемый объект if условие]
```

- **выражение**: это элемент, который добавляется в новый список (можно применить к элементу некоторые операции).
- **элемент**: переменная, которая перебирает все элементы в итерируемом объекте.
- **итерируемый объект**: последовательность или коллекция, по которой идет итерация (например, список, строка, кортеж и т.д.).
- **условие** (необязательно): фильтр, который позволяет выбирать только те элементы, которые удовлетворяют условию.

### **Примеры List Comprehension**

1. **Простой список**
```python
squares = [x**2 for x in range(5)]
print(squares)
```
Результат:
```
[0, 1, 4, 9, 16]
```
Здесь мы создали список квадратов чисел от 0 до 4.

2. **С условием**
```python
even_squares = [x**2 for x in range(10) if x % 2 == 0]
print(even_squares)
```
Результат:
```
[0, 4, 16, 36, 64]
```
Этот список содержит квадраты только четных чисел от 0 до 9.

3. **Трансформация строк**
```python
words = ["apple", "banana", "cherry"]
uppercased = [word.upper() for word in words]
print(uppercased)
```
Результат:
```
['APPLE', 'BANANA', 'CHERRY']
```

### **Преимущества List Comprehension**

- **Читаемость**: Код становится более компактным и читаемым.
- **Производительность**: List Comprehension часто работает быстрее, чем эквивалентный цикл `for`, поскольку использует внутренние оптимизации Python.

---

## **2. Функция `enumerate`**

### **Что такое `enumerate`?**

Функция **`enumerate`** используется для того, чтобы получить индекс элемента в итерируемом объекте. Это особенно полезно, когда нужно работать с элементами списка, но одновременно знать их индекс.

### **Синтаксис `enumerate`**

```python
enumerate(итерируемый объект, start=0)
```
- **итерируемый объект**: последовательность, по которой идет итерация (список, кортеж, строка и т.д.).
- **start** (необязательно): начальный индекс (по умолчанию 0).

### **Пример использования `enumerate`**

```python
fruits = ["apple", "banana", "cherry"]
for index, fruit in enumerate(fruits):
    print(f"Index: {index}, Fruit: {fruit}")
```
Результат:
```
Index: 0, Fruit: apple
Index: 1, Fruit: banana
Index: 2, Fruit: cherry
```

### **Использование `enumerate` с начальным значением индекса**

Если нужно, чтобы индексация начиналась не с 0, можно задать параметр `start`:

```python
fruits = ["apple", "banana", "cherry"]
for index, fruit in enumerate(fruits, start=1):
    print(f"Index: {index}, Fruit: {fruit}")
```
Результат:
```
Index: 1, Fruit: apple
Index: 2, Fruit: banana
Index: 3, Fruit: cherry
```

### **Преимущества использования `enumerate`**

- **Удобство**: избавляет от необходимости вручную отслеживать индекс.
- **Читаемость**: делает код более читаемым и понятным.

---

## **3. Модуль `random`**

Модуль **`random`** в Python предоставляет функции для генерации случайных чисел и выполнения случайных операций. Этот модуль широко используется для моделирования случайных процессов, создания случайных выборок и других задач, где важен элемент случайности.

### **Основные функции модуля `random`**

1. **`random.random()`** — Генерирует случайное число с плавающей точкой от 0 до 1.
```python
import random
print(random.random())
```
Результат:
```
0.7535610469196843
```

2. **`random.randint(a, b)`** — Генерирует случайное целое число в диапазоне от `a` до `b` (включительно).
```python
print(random.randint(1, 10))
```
Результат:
```
7
```

3. **`random.choice(sequence)`** — Выбирает случайный элемент из последовательности (списка, строки и т.д.).
```python
fruits = ["apple", "banana", "cherry"]
print(random.choice(fruits))
```
Результат:
```
banana
```

4. **`random.shuffle(sequence)`** — Перемешивает элементы последовательности на месте.
```python
cards = [1, 2, 3, 4, 5]
random.shuffle(cards)
print(cards)
```
Результат:
```
[4, 3, 1, 5, 2]
```

5. **`random.sample(sequence, k)`** — Возвращает случайную выборку длины `k` из последовательности.
```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(random.sample(numbers, 3))
```
Результат:
```
[7, 3, 9]
```

6. **`random.uniform(a, b)`** — Генерирует случайное число с плавающей точкой в диапазоне от `a` до `b`.
```python
print(random.uniform(1, 10))
```
Результат:
```
3.872531432503028
```

### **Пример: Симуляция подбрасывания монеты**

```python
flip = random.choice(["Heads", "Tails"])
print(f"The result of the coin flip is: {flip}")
```
Результат:
```
The result of the coin flip is: Heads
```

### **Преимущества модуля `random`**

- **Гибкость**: предоставляет множество функций для работы с случайными числами и выборками.
- **Простота**: легко интегрировать в код, решая задачи, связанные с случайностью.

---


## Заключение
- Цикл while обычно используется, когда неизвестно точное количество повторений, а вы в основном полагаетесь на проверку условия для остановки цикла.
- Цикл for обычно используется, когда вы заранее знаете, сколько раз цикл должен выполниться, и вы хотите работать с элементами последовательности.

Выбор между циклом while и циклом for зависит от специфики задачи. Если у вас есть явно определенное количество элементов или требуется обработать каждый элемент в последовательности, то цикл for может быть более удобным выбором. Если же вы ждете определенного события или хотите повторять действие до выполнения определенного условия, то цикл while будет более подходящим.

