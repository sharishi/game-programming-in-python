# Лекция: **Регулярные выражения в Python**

Регулярные выражения (или **регэкспы**) — это мощный инструмент для работы с текстом. Они позволяют искать, заменять, проверять или извлекать данные из строк, соответствующие определенному шаблону. В Python для работы с регулярными выражениями используется встроенный модуль **`re`**.

---

## **1. Что такое регулярные выражения?**

**Регулярные выражения** — это строки, которые описывают шаблоны для поиска и обработки текста. Эти шаблоны состоят из обычных символов, а также специальных символов (метасимволов), которые задают правила для поиска.

Пример простого регулярного выражения:
- **`abc`** — шаблон для поиска строки "abc".

Более сложные шаблоны включают метасимволы, которые позволяют делать поиск более гибким:
- **`^a`** — начало строки с буквы "a".
- **`b$`** — конец строки с буквой "b".
- **`[a-z]`** — любой символ из диапазона от "a" до "z".
- **`\d`** — любая цифра (эквивалентно `[0-9]`).
- **`\w`** — любая буква, цифра или подчеркивание (эквивалентно `[a-zA-Z0-9_]`).

---

## **2. Модуль `re` в Python**

Для работы с регулярными выражениями в Python используется модуль **`re`**. Этот модуль предоставляет несколько функций для поиска, замены и анализа строк с помощью регулярных выражений.

### **2.1 Основные функции модуля `re`**

1. **`re.match(pattern, string)`** — пытается найти совпадение с шаблоном в начале строки. Возвращает объект совпадения, если совпадение найдено, иначе — `None`.

    ```python
    import re
    result = re.match(r'abc', 'abcdef')
    if result:
        print("Match found:", result.group())
    else:
        print("No match")
    ```

    Результат:
    ```
    Match found: abc
    ```

2. **`re.search(pattern, string)`** — ищет совпадение с шаблоном в любой части строки. Возвращает объект совпадения, если совпадение найдено, иначе — `None`.

    ```python
    result = re.search(r'abc', 'xyzabcdef')
    if result:
        print("Search found:", result.group())
    else:
        print("No match")
    ```

    Результат:
    ```
    Search found: abc
    ```

3. **`re.findall(pattern, string)`** — находит все неперекрывающиеся совпадения шаблона в строке и возвращает их в виде списка.

    ```python
    result = re.findall(r'\d+', 'abc 123 def 456 ghi 789')
    print(result)
    ```

    Результат:
    ```
    ['123', '456', '789']
    ```

4. **`re.sub(pattern, repl, string)`** — заменяет все совпадения шаблона в строке на строку `repl`.

    ```python
    result = re.sub(r'\d+', '#', 'abc 123 def 456 ghi 789')
    print(result)
    ```

    Результат:
    ```
    abc # def # ghi #
    ```

5. **`re.split(pattern, string)`** — разделяет строку по совпадениям с шаблоном и возвращает список частей строки.

    ```python
    result = re.split(r'\s+', 'abc 123 def 456 ghi 789')
    print(result)
    ```

    Результат:
    ```
    ['abc', '123', 'def', '456', 'ghi', '789']
    ```

---

## **3. Метасимволы и их использование**

Метасимволы в регулярных выражениях позволяют задавать более сложные шаблоны для поиска и манипуляций с текстом.

Существуют два различных набора метасимволов:
- те, которые используются внутри квадратных скобок,
- те, которые используются вне квадратных скобок
### **3.1 Метасимволы вне квадратных скобок**

#### **1. `^` — Начало строки**

Метасимвол `^` используется для указания начала строки. Это означает, что шаблон должен совпасть с началом текста.

**Пример:**
```python
import re

result = re.match(r'^abc', 'abcdef')
print(result.group())  # abc
```
В этом примере регулярное выражение `^abc` проверяет, начинается ли строка с "abc".

---

#### **2. `$` — Конец строки**

Метасимвол `$` используется для указания конца строки. Шаблон должен совпасть с концом текста.

**Пример:**
```python
import re

result = re.match(r'abc$', 'abcdef')
print(result.group())  # abc
```
Здесь регулярное выражение `abc$` проверяет, заканчивается ли строка на "abc".

---

#### **3. `.` — Любой символ (кроме новой строки)**

Точка `.` представляет собой любой символ, за исключением символа новой строки (`\n`). Это позволяет сопоставлять строки с любыми символами в любом месте.

**Пример:**
```python
import re

result = re.match(r'a.c', 'abc')
print(result.group())  # abc
```
Здесь точка в шаблоне `a.c` соответствует любому символу между "a" и "c". В данном случае совпадает с "abc".

---

#### **4. `[]` — Символьный класс**

Скобки `[]` используются для создания символьных классов, которые позволяют указать диапазон символов. Внутри скобок можно перечислять символы, которые могут быть найдены в строке.

**Пример:**
```python
import re

result = re.match(r'[a-z]', 'b')
print(result.group())  # b
```
Здесь `[a-z]` соответствует любому символу в диапазоне от "a" до "z". В данном примере совпадает с символом "b".

**Пример с несколькими символами:**
```python
result = re.match(r'[abc]', 'b')
print(result.group())  # b
```
Этот шаблон ищет любой из символов "a", "b" или "c".

---

#### **5. `|` — Условный выбор (ИЛИ)**

Метасимвол `|` позволяет создавать выбор между несколькими вариантами. Это эквивалент логическому "ИЛИ" в регулярных выражениях.

**Пример:**
```python
import re

result = re.match(r'cat|dog', 'dog')
print(result.group())  # dog
```
В этом примере регулярное выражение `cat|dog` будет соответствовать либо "cat", либо "dog". В данном случае совпало "dog".

---

#### **6. `()` — Группировка и подмаски**

Круглые скобки `()` используются для группировки частей выражения, чтобы указать, какие символы или выражения должны быть обработаны вместе. Это также позволяет захватывать группы совпадений.

**Пример:**
```python
import re

result = re.match(r'(abc)', 'abcdef')
print(result.group(1))  # abc
```
В этом примере выражение `(abc)` захватывает строку "abc", которая затем доступна через `group(1)`.

---

#### **7. `?` — 0 или 1 вхождение (квантификатор)**

Метасимвол `?` является квантификатором, который указывает, что предыдущий символ или группа может появиться 0 или 1 раз.

**Пример:**
```python
import re

result = re.match(r'colou?r', 'color')
print(result.group())  # color
```
Здесь регулярное выражение `colou?r` соответствует как "color", так и "colour", так как буква "u" является необязательной.

---

#### **8. `*` — 0 или более вхождений (квантификатор)**

Метасимвол `*` указывает, что предыдущий символ или группа может появиться 0 или более раз.

**Пример:**
```python
import re

result = re.match(r'lo*', 'look')
print(result.group())  # loo
```
Здесь регулярное выражение `lo*` находит строку, которая начинается с "l", за которой могут следовать 0 или более символов "o". В примере "look" совпадает с "loo".

---

#### **9. `+` — 1 или более вхождений (квантификатор)**

Метасимвол `+` указывает, что предыдущий символ или группа должна появиться хотя бы один раз или более.

**Пример:**
```python
import re

result = re.match(r'lo+', 'look')
print(result.group())  # loo
```
В этом примере регулярное выражение `lo+` находит "l", за которым следуют одна или более букв "o".

---

#### **10. Преобразование жадных квантификаторов в ленивые**

Метасимвол `?` также используется для превращения "жадных" квантификаторов (которые захватывают как можно больше символов) в "ленивые", которые захватывают как можно меньше символов.

**Пример с жадным квантификатором:**
```python
import re

result = re.match(r'<.*>', '<div>content</div>')
print(result.group())  # <div>content</div>
```
Здесь `.*` захватывает всю строку, включая "div", так как это жадный квантификатор.

**Пример с ленивым квантификатором:**
```python
result = re.match(r'<.*?>', '<div>content</div>')
print(result.group())  # <div>
```
Добавление `?` делает квантификатор ленивым, и он захватывает как можно меньше символов, в данном случае только первый тег `<div>`.

---
В регулярных выражениях Python внутри квадратных скобок используются специальные метасимволы для создания символьных классов и диапазонов. Эти метасимволы позволяют определять, какие символы могут быть найдены на определенной позиции в строке.

### **3.2 Метасимволы внутри квадратных скобок**

---

#### **1. `-` — Диапазон символов**

Метасимвол `-` используется для обозначения диапазона символов. Диапазон может быть числовым или буквенным. Символы в диапазоне могут быть представлены в порядке от меньшего к большему.

**Пример:**
```python
import re

# Диапазон от 'a' до 'z'
result = re.match(r'[a-z]', 'g')
print(result.group())  # g

# Диапазон от '0' до '9'
result = re.match(r'[0-9]', '5')
print(result.group())  # 5
```
Здесь `[a-z]` соответствует любому символу от 'a' до 'z', а `[0-9]` соответствует любому числу от 0 до 9.

---

#### **2. `^` — Отрицание (когда он первым символом в скобках)**

Если символ `^` стоит первым в квадратных скобках, он инвертирует символьный класс, т.е. создаёт класс, который соответствует любому символу, **кроме** тех, которые перечислены в скобках.

**Пример:**
```python
import re

# Совпадает с любым символом, который не является цифрой
result = re.match(r'[^0-9]', 'a')
print(result.group())  # a

# Совпадает с любым символом, который не является буквой 'a', 'b' или 'c'
result = re.match(r'[^abc]', 'd')
print(result.group())  # d
```
Здесь `[^0-9]` соответствует любому символу, который не является цифрой, а `[^abc]` — любому символу, кроме 'a', 'b' и 'c'.

---

#### **3. `[]` — Символьный класс**

Квадратные скобки `[]` используются для создания символьных классов, в которых перечисляются символы, из которых один должен совпасть с символом в строке.

**Пример:**
```python
import re

# Совпадает с любым символом, который является либо 'a', либо 'b'
result = re.match(r'[ab]', 'a')
print(result.group())  # a

# Совпадает с любым символом, который является буквой или цифрой
result = re.match(r'[a-zA-Z0-9]', '1')
print(result.group())  # 1
```
В этом примере `[ab]` соответствует любому из символов 'a' или 'b', а `[a-zA-Z0-9]` — любому символу из диапазона 'a-z', 'A-Z' или цифре от '0' до '9'.

---

Здесь `[\s]` соответствует любому пробельному символу, например пробелу, табуляции или новой строке.

#### **4. Специальные последовательности**
Специальные последовательности в регулярных выражениях Python — это символы, начинающиеся с обратной косой черты (`\`), которые имеют особое значение и позволяют более точно контролировать, какие символы будут соответствовать вашему шаблону. Эти последовательности упрощают создание паттернов и расширяют возможности поиска.

#### **1. `\f` — Разрыв страницы**
  
Метасимвол `\f` соответствует символу разрыва страницы. Это спецсимвол, который используется в текстах для обозначения конца страницы (например, в старых форматах документов).

**Пример:**
```python
import re

# Совпадает с символом разрыва страницы
result = re.match(r'\f', '\f')
if result:
    print("Разрыв страницы найден.")
```

---

#### **2. `\n` — Перевод строки (Newline)**

Метасимвол `\n` соответствует символу перевода строки, который используется в текстах для перехода на новую строку.

**Пример:**
```python
import re

# Совпадает с символом перевода строки
result = re.match(r'\n', '\n')
if result:
    print("Перевод строки найден.")
```

---

#### **3. `\r` — Возврат каретки (Carriage Return)**

Метасимвол `\r` соответствует символу возврата каретки, который используется для перемещения курсора в начало строки, без перехода на новую строку.

**Пример:**
```python
import re

# Совпадает с символом возврата каретки
result = re.match(r'\r', '\r')
if result:
    print("Возврат каретки найден.")
```

---

#### **4. `\t` — Табуляция**

Метасимвол `\t` соответствует символу табуляции, который используется для создания отступов или выравнивания текста в столбцы.

**Пример:**
```python
import re

# Совпадает с символом табуляции
result = re.match(r'\t', '\t')
if result:
    print("Табуляция найдена.")
```

---

#### **5. `\d` — Цифра (Decimal Digit)**

Метасимвол `\d` соответствует любому десятичному числу (цифре) от 0 до 9.

**Пример:**
```python
import re

# Совпадает с цифрой
result = re.match(r'\d', '5')
if result:
    print("Цифра найдена.")
```

---

#### **6. `\D` — Не цифра (Non-digit)**

Метасимвол `\D` соответствует любому символу, который не является цифрой.

**Пример:**
```python
import re

# Совпадает с нецифровым символом
result = re.match(r'\D', 'a')
if result:
    print("Не цифра найдена.")
```

---

#### **7. `\s` — Пробельный символ (Whitespace)**

Метасимвол `\s` соответствует любому пробельному символу, включая пробел, табуляцию, символ новой строки, возврат каретки, и другие.

**Пример:**
```python
import re

# Совпадает с пробельным символом
result = re.match(r'\s', ' ')
if result:
    print("Пробельный символ найден.")
```

---

#### **8. `\S` — Не пробельный символ (Non-whitespace)**

Метасимвол `\S` соответствует любому символу, который **не** является пробельным.

**Пример:**
```python
import re

# Совпадает с непустым символом
result = re.match(r'\S', 'a')
if result:
    print("Не пробельный символ найден.")
```

---

#### **9. `\w` — Символ слова (Word character)**

Метасимвол `\w` соответствует любому символу, который является буквой (заглавной или строчной), цифрой или знаком подчеркивания (`_`).

**Пример:**
```python
import re

# Совпадает с символом слова
result = re.match(r'\w', 'a')
if result:
    print("Символ слова найден.")
```

---

#### **10. `\W` — Не символ слова (Non-word character)**

Метасимвол `\W` соответствует любому символу, который не является буквой, цифрой или знаком подчеркивания (`_`).

**Пример:**
```python
import re

# Совпадает с несимволом слова
result = re.match(r'\W', '@')
if result:
    print("Не символ слова найден.")
```
В регулярных выражениях Python также существуют дополнительные специальные последовательности, которые работают с определенными позициями в строках. Эти последовательности позволяют точнее контролировать, где должны находиться символы для того, чтобы они соответствовали заданному шаблону.

### Специальные последовательности для позиционных выражений

---

#### **11. `\A` — Начало строки**

Метасимвол `\A` используется для указания, что шаблон должен совпасть только в начале всей строки (не учитывая многострочный режим). Это аналогично символу `^`, но `\A` всегда соответствует началу строки, в отличие от `^`, который может работать иначе в разных контекстах, например, в многострочном режиме.

**Пример:**
```python
import re

# Совпадает с "start" только в начале строки
result = re.match(r'\Astart', 'start here')
if result:
    print("Совпадение найдено в начале строки.")
```

---

#### **12. `\b` — Граница слова (word boundary)**

Метасимвол `\b` обозначает границу слова. Он соответствует позиции между символом, который является частью слова (буквы, цифры или подчеркивания), и символом, который не является частью слова (например, пробел, пунктуация или начало/конец строки).

**Пример:**
```python
import re

# Совпадает с "word", если оно стоит в начале или в конце слова
result = re.search(r'\bword\b', 'This is a word.')
if result:
    print("Совпадение найдено в начале или в конце слова.")
```

**Примечание:** `\b` также срабатывает на границе строки, если слово начинается или заканчивается в ней.

---

#### **13. `\B` — Не граница слова (non-word boundary)**

Метасимвол `\B` соответствует любой позиции, которая **не является** границей слова. Это означает, что символы должны быть внутри слова, а не в начале или в конце.

**Пример:**
```python
import re

# Совпадает с "word" в середине другого слова, но не в начале или конце
result = re.search(r'\Bword\B', 'swordfish')
if result:
    print("Совпадение найдено внутри слова.")
```

---

#### **14. `\Z` — Конец строки**

Метасимвол `\Z` соответствует концу строки. Это аналог символа `$`, но `\Z` всегда будет работать как конец строки, в то время как `$` может работать иначе в многострочном режиме.

**Пример:**
```python
import re

# Совпадает с "end" только в конце строки
result = re.search(r'end\Z', 'This is the end')
if result:
    print("Совпадение найдено в конце строки.")
```


---
### **3.2 Квантификаторы**

Квантификаторы указывают, сколько раз должен повторяться элемент в регулярном выражении.

- **`*`** — 0 или более раз.
  
    ```python
    result = re.findall(r'lo*', 'look at this loop')
    print(result)  # ['lo', 'loo', 'loop']
    ```

- **`+`** — 1 или более раз.
  
    ```python
    result = re.findall(r'lo+', 'look at this loop')
    print(result)  # ['loo', 'loop']
    ```

- **`?`** — 0 или 1 раз.
  
    ```python
    result = re.findall(r'lo?', 'look at this loop')
    print(result)  # ['lo', 'lo']
    ```

- **`{n}`** — ровно n раз.
  
    ```python
    result = re.findall(r'lo{2}', 'look at this looop')
    print(result)  # ['loo']
    ```

- **`{n, m}`** — от n до m раз.
  
    ```python
    result = re.findall(r'lo{1,3}', 'look at this loooop')
    print(result)  # ['loo', 'loo']
    ```

---

## **4. Использование групп и захватов**

Регулярные выражения позволяют выделять группы символов, которые можно использовать позже. Это осуществляется с помощью круглых скобок.

### **4.1 Группы**

Группировка позволяет извлекать части совпавшей строки.

```python
result = re.match(r'(\d+)-(\d+)', '123-456')
print(result.groups())  # ('123', '456')
```

- **`group(0)`** — вся строка.
- **`group(1), group(2), ...`** — соответствующие группы.

### **4.2 Ненумерованные группы**

Если не нужно возвращать результат для конкретной группы, можно использовать ненумерованные группы с `?:`.

```python
result = re.match(r'(?:\d+)-(\d+)', '123-456')
print(result.groups())  # ('456',)
```

---

## **5. Пример использования регулярных выражений**

Допустим, у нас есть строка, и мы хотим извлечь все email-адреса.

```python
import re

text = "Contact us at support@example.com or sales@company.org"
emails = re.findall(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,7}\b', text)

print(emails)
```

Результат:
```
['support@example.com', 'sales@company.org']
```

---
### 6. Утверждения в регулярных выражениях (Lookahead и Lookbehind)

Утверждения в регулярных выражениях позволяют проверять условия, которые должны быть выполнены до или после текущей позиции в строке. Эти утверждения не используют символы из строки, а лишь проверяют, соответствуют ли символы в определенных местах условиям. Утверждения могут быть **положительными** или **отрицательными**, а также могут касаться **последующего** текста (lookahead) или **предшествующего** текста (lookbehind).



#### **1. Положительное утверждение (positive lookahead)**

Положительное утверждение, или **lookahead**, проверяет, что за текущей позицией находится заданный паттерн. Оно записывается как `(?=...)`, где `...` — это паттерн, который должен следовать за текущей позицией.

**Пример:**
```python
import re

addresses = ['str. Nucului', 'str. Pushkin', 'Mateevici str', 'Kostrikin blvrd']
my_pattern = '.*(?=str$)'  # Положительное lookahead, проверяет, что после "str" стоит конец строки

for item in addresses:
    result = re.match(my_pattern, item)
    if result:
        print('I found it:', item)
    else:
        print('Nothing!')
```

**Объяснение:**
- Паттерн `.*(?=str$)` ищет любой символ (`.*`), после которого **обязательно** должен следовать текст `"str"`, и строка должна завершаться на это слово (`$`).
- В данном примере только строки, заканчивающиеся на `"str"`, будут успешно сопоставляться с паттерном.

**Результат:**
```
I found it: Mateevici str
Nothing!
Nothing!
Nothing!
```

---

#### **2. Отрицательное утверждение (negative lookahead)**

Отрицательное утверждение (или **negative lookahead**) проверяет, что за текущей позицией **не следует** определенный паттерн. Оно записывается как `(?!...)`.

**Пример:**
```python
import re

addresses = ['str. Nucului', 'str. Pushkin', 'Mateevici str', 'Kostrikin blvrd']
my_pattern = '.*(?!str$)'  # Отрицательное lookahead, проверяет, что после чего не следует "str" в конце строки

for item in addresses:
    result = re.match(my_pattern, item)
    if result:
        print('I found it:', item)
    else:
        print('Nothing!')
```

**Объяснение:**
- Паттерн `.*(?!str$)` ищет любой символ (`.*`), за которым не следует `"str"`, и строка не должна заканчиваться на `"str"`.
- В данном примере строки, заканчивающиеся на `"str"`, не будут сопоставляться с паттерном.

**Результат:**
```
I found it: str. Nucului
I found it: str. Pushkin
Nothing!
I found it: Kostrikin blvrd
```

---

#### **3. Положительное утверждение перед (positive lookbehind)**

Положительное утверждение перед (или **lookbehind**) проверяет, что перед текущей позицией находится определенный паттерн. Оно записывается как `(?<=...)`.

**Пример:**
```python
import re

text = 'The quick brown fox jumps over the lazy dog'
my_pattern = '(?<=quick ).*'  # Положительное lookbehind, проверяет, что перед словом "quick" стоит слово "quick"

result = re.search(my_pattern, text)
if result:
    print('Found:', result.group())
else:
    print('Nothing!')
```

**Объяснение:**
- Паттерн `(?<=quick ).*` ищет все, что идет после слова `"quick"`.
- Это утверждение будет проверять, что перед текущей позицией находится слово `"quick"`, и все, что идет после, будет захвачено.

**Результат:**
```
Found: brown fox jumps over the lazy dog
```

---

#### **4. Отрицательное утверждение перед (negative lookbehind)**

Отрицательное утверждение перед (или **negative lookbehind**) проверяет, что перед текущей позицией **не находится** определенный паттерн. Оно записывается как `(?<!...)`.

**Пример:**
```python
import re

text = 'The quick brown fox jumps over the lazy dog'
my_pattern = '(?<!quick ).*'  # Отрицательное lookbehind, проверяет, что перед словом "quick" нет "quick"

result = re.search(my_pattern, text)
if result:
    print('Found:', result.group())
else:
    print('Nothing!')
```

**Объяснение:**
- Паттерн `(?<!quick ).*` ищет все, что не идет сразу после слова `"quick"`.
- В этом случае, он не будет захватывать текст, который идет после `"quick"`.

**Результат:**
```
Found: brown fox jumps over the lazy dog
```

---

## **7. Заключение**

Регулярные выражения — это мощный инструмент для работы с текстом. Они позволяют создавать гибкие и быстрые алгоритмы поиска, замены и извлечения информации. В Python модуль

 `re` предоставляет все необходимые инструменты для эффективной работы с регулярными выражениями, и их использование может существенно облегчить обработку текста.