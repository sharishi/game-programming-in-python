# Словари и кортежи в Python

### Словари (dict)

**Словарь** в Python — это неупорядоченная, изменяемая коллекция, которая хранит данные в виде пар "ключ-значение". Каждый ключ в словаре уникален, и его значение может быть любого типа. Словарь может быть использован для быстрого поиска значений по ключам.

#### Основные характеристики:
- **Неупорядоченные** (до Python 3.7, начиная с этой версии словари сохраняют порядок вставки).
- **Изменяемые** (можно добавлять, изменять или удалять элементы).
- **Ключи уникальны**: два одинаковых ключа в одном словаре быть не могут.

Словари оптимизированы для извлечения данных. Мы должны знать ключ для
произведения доступа к значению\
В Python словари определены в фигурных скобках {}, где каждый элемент является парой
в форме - `key:valuе`
### **Ключи словарей в Python**

В Python ключами словаря могут быть только **неизменяемые (immutable)** типы данных. Это связано с тем, что ключи словаря должны быть хешируемыми, а изменяемые типы, такие как списки и множества, не могут быть использованы в качестве ключей, поскольку их хеш может изменяться.

**Что можно использовать в качестве ключей:**
1. **Числа** (int, float).
2. **Строки** (str).
3. **Кортежи** (tuple), если они содержат только неизменяемые элементы.
4. **frozenset** — неизменяемая версия множества, которая может использоваться в качестве ключа.
5. **Boolean типы** (True, False).

**Пример использования `frozenset` в качестве ключа:**
```python
students_courses = {}
name_age = frozenset(['Anatoly', 32])
students_courses.update({name_age: ['Python', 'C++']})

print(students_courses)  # => {frozenset({32, 'Anatoly'}): ['Python', 'C++']}
```

**Что нельзя использовать в качестве ключей:**
- **Списки** (list)
- **Множества** (set)
- **Другие изменяемые типы данных**

Таким образом, для использования сложных структур данных в качестве ключей (например, пары значений), можно использовать `frozenset`, так как он является неизменяемым.
### Синтаксис:
```python
# Создание словаря
my_dict = {"name": "Alice", "age": 25, "city": "New York"}

# Доступ к значению по ключу
print(my_dict["name"])  # Alice

# Добавление нового элемента
my_dict["job"] = "Engineer"
print(my_dict)  # {'name': 'Alice', 'age': 25, 'city': 'New York', 'job': 'Engineer'}

# Удаление элемента
del my_dict["age"]
print(my_dict)  # {'name': 'Alice', 'city': 'New York', 'job': 'Engineer'}

# Получение всех ключей или значений
print(my_dict.keys())   # dict_keys(['name', 'city', 'job'])
print(my_dict.values()) # dict_values(['Alice', 'New York', 'Engineer'])
```

## Методы словаря:

### 1. **`get(key)`**
Метод `get(key)` возвращает значение по указанному ключу. Если ключ отсутствует, то возвращается `None` (или указанный второй аргумент, если он передан).

Пример:
```python
my_dict = {"name": "Alice", "age": 25}

# Получение значения по ключу
print(my_dict.get("name"))  # "Alice"
print(my_dict.get("gender"))  # None

# Можно указать значение по умолчанию
print(my_dict.get("gender", "Unknown"))  # "Unknown"
```

### 2. **`items()`**
Метод `items()` возвращает представление всех пар (ключ, значение) в словаре в виде итератора.

Пример:
```python
my_dict = {"name": "Alice", "age": 25, "city": "New York"}

# Получение всех пар ключ-значение
print(my_dict.items())  # dict_items([('name', 'Alice'), ('age', 25), ('city', 'New York')])

# Преобразуем в список
print(list(my_dict.items()))  # [('name', 'Alice'), ('age', 25), ('city', 'New York')]
```

### 3. **`pop(key)`**
Метод `pop(key)` удаляет пару "ключ-значение" по ключу и возвращает соответствующее значение. Если ключ отсутствует, будет выброшено исключение `KeyError`.

Пример:
```python
my_dict = {"name": "Alice", "age": 25, "city": "New York"}

# Удаляем пару с ключом "age"
value = my_dict.pop("age")
print(value)  # 25
print(my_dict)  # {'name': 'Alice', 'city': 'New York'}

# Попытка удалить отсутствующий ключ вызовет ошибку
# my_dict.pop("gender")  # KeyError: 'gender'
```

### 4. **`update()`**
Метод `update()` используется для обновления словаря новыми парами "ключ-значение". Если ключ уже существует, его значение будет обновлено. Если ключ отсутствует, будет добавлена новая пара "ключ-значение".

Пример:
```python
my_dict = {"name": "Alice", "age": 25}

# Обновление словаря новыми парами ключ-значение
my_dict.update({"age": 26, "city": "New York"})
print(my_dict)  # {'name': 'Alice', 'age': 26, 'city': 'New York'}

# Можно обновить словарь с помощью другого словаря
other_dict = {"gender": "female", "country": "USA"}
my_dict.update(other_dict)
print(my_dict)  # {'name': 'Alice', 'age': 26, 'city': 'New York', 'gender': 'female', 'country': 'USA'}
```
### 5. **`keys()`**
Метод возвращает представление всех ключей в словаре. Это представление является итератором, и его можно преобразовать в список или использовать в цикле.

Пример:
```python
my_dict = {"name": "Alice", "age": 25, "city": "New York"}

# Получение всех ключей
keys = my_dict.keys()
print(keys)  # dict_keys(['name', 'age', 'city'])

# Преобразуем в список
print(list(keys))  # ['name', 'age', 'city']

# Использование в цикле
for key in my_dict.keys():
    print(key)
```
### 6. **`popitem()`** 
Метод удаляет и возвращает пару (ключ, значение) из словаря. Пара возвращается как кортеж `(key, value)`. В Python 3.7+ элемент, который будет удален, — это последняя добавленная пара, так как словари стали упорядоченными начиная с этой версии.

Пример:

```python
my_dict = {"name": "Alice", "age": 25, "city": "New York"}

# Удаление и возвращение последнего элемента
key, value = my_dict.popitem()
print(key, value)  # например: 'city New York'

# Проверим, что элемент удален
print(my_dict)  # {'name': 'Alice', 'age': 25}
```
### 6. **`values()`** 
Метод возвращает все значения словаря в виде **объекта `dict_values`**, который является итерабельным. Он не возвращает список, но вы можете преобразовать его в список с помощью функции `list()`.

Пример:

```python
my_dict = {"name": "Alice", "age": 25, "city": "New York"}

# Получение всех значений словаря
values = my_dict.values()
print(values)  # dict_values(['Alice', 25, 'New York'])

# Преобразование в список
values_list = list(values)
print(values_list)  # ['Alice', 25, 'New York']
```
Методы **`count()`** и **`index()`** обычно используются в списках, но не применимы напрямую к словарям, так как словарь представляет собой набор пар "ключ-значение". Однако, я могу объяснить их для работы со списками:

### 7. **`count()`**:
Метод **`count()`** возвращает количество вхождений элемента в список.

**Пример**:

```python
my_list = [1, 2, 3, 4, 2, 5, 2]

# Подсчёт количества вхождений числа 2
count = my_list.count(2)
print(count)  # Выведет 3
```

### 8. **`index()`**:
Метод **`index()`** возвращает индекс первого вхождения элемента в список. Если элемент не найден, возникает ошибка **`ValueError`**.

**Пример**:

```python
my_list = [1, 2, 3, 4, 2, 5]

# Получение индекса первого вхождения числа 2
index = my_list.index(2)
print(index)  # Выведет 1

# Попытка найти элемент, которого нет в списке, вызовет ошибку
# my_list.index(6)  # ValueError: 6 is not in list
```
### 9. **`fromkeys()`** 
Метод используется для создания нового словаря с заданными ключами, при этом все значения будут иметь одинаковое значение по умолчанию. Этот метод возвращает новый словарь, в котором каждому ключу будет присвоено значение, которое передано в качестве второго аргумента, или `None`, если значение не указано.

### Синтаксис:
```python
dict.fromkeys(iterable, value=None)
```

- **`iterable`** — это последовательность (например, список, кортеж, строка), которая содержит ключи.
- **`value`** — значение, которое будет присвоено всем ключам (по умолчанию `None`).

### Пример 1: Использование **`fromkeys()`** с заданным значением:

```python
keys = ['a', 'b', 'c']
new_dict = dict.fromkeys(keys, 0)
print(new_dict)  # Выведет {'a': 0, 'b': 0, 'c': 0}
```

В этом примере создаётся словарь, где все ключи ('a', 'b', 'c') получают значение 0.

### Пример 2: Использование **`fromkeys()`** без значения:

```python
keys = ['a', 'b', 'c']
new_dict = dict.fromkeys(keys)
print(new_dict)  # Выведет {'a': None, 'b': None, 'c': None}
```

Здесь значение по умолчанию для всех ключей будет `None`.

Этот метод полезен, когда нужно создать словарь с набором ключей, но значениями будут быть одинаковыми или нужно просто инициализировать словарь с дефолтным значением.
### 10.  **`clear()`** 
Метод используется для удаления всех элементов из словаря. После его применения словарь становится пустым.

### Синтаксис:
```python
dict.clear()
```

- **Этот метод не принимает аргументов.**

### Пример использования **`clear()`**:

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
print("До очистки:", my_dict)  # Выведет: {'a': 1, 'b': 2, 'c': 3}

my_dict.clear()
print("После очистки:", my_dict)  # Выведет: {}
```

После вызова метода **`clear()`** все пары "ключ-значение" из словаря будут удалены, и словарь станет пустым.
Этот метод полезен, когда нужно очистить словарь от всех элементов, но при этом сам словарь остаётся доступным для дальнейшего использования.
### 11. **`copy()`**

Метод **`copy()`** используется для создания поверхностной копии словаря. Это означает, что создается новый словарь, содержащий те же ключи и значения, что и оригинальный, но изменения в новом словаре не повлияют на оригинальный.

### Синтаксис:
```python
new_dict = dict.copy()
```

### Пример использования **`copy()`**:
```python
original_dict = {'a': 1, 'b': 2, 'c': 3}
new_dict = original_dict.copy()

print("Оригинальный словарь:", original_dict)  # Выведет: {'a': 1, 'b': 2, 'c': 3}
print("Копия словаря:", new_dict)  # Выведет: {'a': 1, 'b': 2, 'c': 3}

# Изменим копию
new_dict['a'] = 10
print("Измененная копия:", new_dict)  # Выведет: {'a': 10, 'b': 2, 'c': 3}
print("Оригинальный словарь после изменения копии:", original_dict)  # Выведет: {'a': 1, 'b': 2, 'c': 3}
```

Важно заметить, что метод **`copy()`** создаёт поверхностную копию, то есть, если значения в словаре — это изменяемые объекты (например, списки), то они будут изменяться в обоих словарях.

---

### 12. **`setdefault()`**

Метод **`setdefault()`** используется для получения значения по ключу, и если этого ключа нет в словаре, метод добавит ключ с указанным значением. Он возвращает значение, ассоциированное с ключом, если ключ существует, или добавляет ключ с заданным значением и возвращает это значение.

### Синтаксис:
```python
dict.setdefault(key, default_value)
```

- **`key`** — ключ, значение которого необходимо получить.
- **`default_value`** — значение, которое будет установлено по умолчанию, если ключ отсутствует. Если не указано, то значением по умолчанию будет `None`.

### Пример использования **`setdefault()`**:
```python
my_dict = {'a': 1, 'b': 2, 'c': 3}

# Получаем значение для ключа 'b'
print(my_dict.setdefault('b', 100))  # Выведет: 2 (значение для ключа 'b')

# Ключ 'd' отсутствует, добавляем его с значением 4
print(my_dict.setdefault('d', 4))  # Выведет: 4

# Словарь после добавления нового ключа
print(my_dict)  # Выведет: {'a': 1, 'b': 2, 'c': 3, 'd': 4}

# Если ключ 'a' уже существует, он не изменится
print(my_dict.setdefault('a', 10))  # Выведет: 1 (значение для ключа 'a')
```

Метод **`setdefault()`** полезен, когда нужно безопасно добавить новый ключ в словарь, не опасаясь его перезаписывания, если он уже существует.

**Особенности**:
- Этот метод полезен для перебора значений словаря.
- Значения могут быть любого типа, включая другие коллекции, функции и т. д.

**Особенности**:
- Если словарь пуст, вызов **`popitem()`** вызовет ошибку `KeyError`.
- В Python 3.6 и более ранних версиях словари не были упорядочены, и метод **`popitem()`** возвращал произвольную пару.
**Особенности**:
- Метод **`keys()`** возвращает представление ключей, а не сам список. Это значит, что оно не будет копировать ключи в память, а будет работать с текущими данными словаря.
- Это представление поддерживает итерацию, поэтому можно использовать его в цикле или преобразовать в другие коллекции (например, в список).
Эти методы являются основными для работы со словарями, позволяя выполнять поиск, изменение, удаление и добавление элементов.

### Кортежи (tuple)

**Кортеж** — это упорядоченная коллекция данных, которая является **неизменяемой**. Элементы кортежа могут быть любого типа, и кортежи могут содержать повторяющиеся элементы. Они часто используются для хранения данных, которые не должны изменяться.

#### Основные характеристики:
- **Упорядоченные** (сохраняют порядок элементов).
- **Неизменяемые** (нельзя изменять элементы после создания).
- **Индексация**: к элементам можно обращаться по индексу.

Кортежи используются для защиты данных от записи и, как правило, работают быстрее, чем
списки, поскольку они не могут изменяться динамически
#### Синтаксис:
```python
# Создание кортежа
my_tuple = (1, 2, 3, 4, 5)

# Доступ к элементам
print(my_tuple[0])  # 1

# Кортежи могут содержать различные типы данных
mixed_tuple = (1, "apple", 3.14, True)

# Кортежи поддерживают срезы
print(my_tuple[1:3])  # (2, 3)
```
## Основные методы кортежа:

### 1. **`count(value)`**
Этот метод возвращает количество вхождений значения **`value`** в кортеж.

#### Пример:
```python
my_tuple = (1, 2, 3, 1, 4, 1)
print(my_tuple.count(1))  # Выведет: 3
```

### 2. **`index(value, start=0, end=len(tuple))`**
Метод **`index()`** возвращает индекс первого элемента, равного **`value`**. Также можно указать диапазон поиска с помощью параметров **`start`** и **`end`**.

#### Пример:
```python
my_tuple = (1, 2, 3, 4, 5)
print(my_tuple.index(3))  # Выведет: 2

# С параметрами start и end
print(my_tuple.index(4, 2, 5))  # Выведет: 3
```

### 3. **`__contains__(value)`**
Метод **`__contains__()`** проверяет, содержится ли значение **`value`** в кортеже. Он используется, когда вы применяете оператор **`in`**.

#### Пример:
```python
my_tuple = (1, 2, 3, 4, 5)
print(3 in my_tuple)  # Выведет: True
print(6 in my_tuple)  # Выведет: False
```

### 4. **`len()`**
Хотя **`len()`** — это встроенная функция, она часто используется с кортежами для получения количества элементов в кортеже.

#### Пример:
```python
my_tuple = (1, 2, 3, 4, 5)
print(len(my_tuple))  # Выведет: 5
```

### 5. **`max()` и `min()`**
Это не методы кортежей напрямую, но их можно использовать с кортежами для получения максимального или минимального значения.

#### Пример:
```python
my_tuple = (1, 2, 3, 4, 5)
print(max(my_tuple))  # Выведет: 5
print(min(my_tuple))  # Выведет: 1
```

Кортежи не поддерживают методы добавления, удаления или изменения элементов, так как они неизменяемы. Однако вышеупомянутые методы полезны для анализа содержимого кортежа.
#### Преимущества кортежей:
- **Производительность**: кортежи занимают меньше памяти и быстрее работают в сравнении с списками.
- **Использование в качестве ключей в словарях**: поскольку кортежи неизменяемы, их можно использовать как ключи в словарях (в отличие от списков).

#### Операции с кортежами:
- **Конкатенация**: можно объединять два кортежа.
```python
tuple1 = (1, 2)
tuple2 = (3, 4)
print(tuple1 + tuple2)  # (1, 2, 3, 4)
```
- **Умножение**: можно повторить кортеж несколько раз.
```python
tuple1 = (1, 2)
print(tuple1 * 3)  # (1, 2, 1, 2, 1, 2)
```

**Сравнение**:
- Словари удобны для хранения пар "ключ-значение", когда необходим быстрый доступ по ключу.
- Кортежи лучше подходят для представления неизменяемых коллекций данных, когда порядок важен, но элементы не должны изменяться.

![img.png](../images/l_3/img.png)

## Конструкторы коллекций

В Python существуют специальные функции, называемые **конструкторами коллекций**, которые позволяют преобразовывать данные в различные типы коллекций. Эти функции часто используются для создания новых коллекций из других типов данных или для преобразования данных в коллекции. Вот несколько основных конструкторов коллекций:

#### 1. **`list()`**
Функция `list()` используется для создания списка из итерируемого объекта (например, строки, множества, кортежа, диапазона и т. д.). Она позволяет легко преобразовать другие коллекции в список.

**Пример**:
```python
# Преобразование строки в список
string = "hello"
list_from_string = list(string)
print(list_from_string)  # ['h', 'e', 'l', 'l', 'o']

# Преобразование диапазона в список
range_obj = range(5)
list_from_range = list(range_obj)
print(list_from_range)  # [0, 1, 2, 3, 4]
```

#### 2. **`tuple()`**
Функция `tuple()` создает кортеж из любого итерируемого объекта. Кортежи аналогичны спискам, но они неизменяемы.

**Пример**:
```python
# Преобразование списка в кортеж
my_list = [1, 2, 3, 4]
tuple_from_list = tuple(my_list)
print(tuple_from_list)  # (1, 2, 3, 4)

# Преобразование строки в кортеж
string = "hello"
tuple_from_string = tuple(string)
print(tuple_from_string)  # ('h', 'e', 'l', 'l', 'o')
```

#### 3. **`set()`**
Функция `set()` используется для создания множества из итерируемого объекта. Множества в Python — это неупорядоченные коллекции, которые не допускают повторяющихся элементов.

**Пример**:
```python
# Преобразование списка в множество
my_list = [1, 2, 2, 3, 4, 4]
set_from_list = set(my_list)
print(set_from_list)  # {1, 2, 3, 4}

# Преобразование строки в множество
string = "hello"
set_from_string = set(string)
print(set_from_string)  # {'h', 'e', 'l', 'o'}
```

#### 4. **`dict()`**
Функция `dict()` используется для создания словаря. Обычно она принимает итерируемый объект, состоящий из пар ключ-значение. Также можно передать аргументы в виде ключевых слов.

**Пример**:
```python
# Преобразование списка кортежей в словарь
my_list = [("apple", 1), ("banana", 2), ("cherry", 3)]
dict_from_list = dict(my_list)
print(dict_from_list)  # {'apple': 1, 'banana': 2, 'cherry': 3}

# Создание словаря с использованием ключевых слов
dict_from_keywords = dict(apple=1, banana=2, cherry=3)
print(dict_from_keywords)  # {'apple': 1, 'banana': 2, 'cherry': 3}
```

#### 5. **`frozenset()`**
Функция `frozenset()` создает неизменяемое множество. Это полезно, если необходимо создать множество, которое не будет изменяться после его создания.

**Пример**:
```python
# Преобразование списка в frozenset
my_list = [1, 2, 2, 3, 4]
frozenset_from_list = frozenset(my_list)
print(frozenset_from_list)  # frozenset({1, 2, 3, 4})

# Преобразование строки в frozenset
string = "hello"
frozenset_from_string = frozenset(string)
print(frozenset_from_string)  # frozenset({'h', 'e', 'l', 'o'})
```

### Зачем использовать конструктора коллекций?
Конструкторы коллекций полезны, когда нужно:
- Преобразовать данные из одного типа в другой (например, из строки в список).
- Убедиться, что коллекция не содержит повторяющихся элементов (например, при создании множества).
- Создать коллекцию с ограничениями, как например, неизменяемое множество с `frozenset()`.

Эти функции позволяют гибко работать с данными, удобно преобразуя их в нужные типы коллекций для дальнейших операций.