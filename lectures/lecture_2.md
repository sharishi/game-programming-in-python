# Строки, списки и множества в Python

---
### 1. Что такое индексирование?

**Индексирование** — это способ доступа к отдельным элементам последовательности (например, строк, списков или кортежей) с помощью их позиции, которая называется индексом.  

- **Индексы в Python начинаются с 0** для первого элемента.  
- **Отрицательные индексы** используются для доступа к элементам с конца последовательности.  
- Индексирование позволяет извлекать, изменять (в случае изменяемых типов) или использовать элементы в различных операциях.  

**Общая формула для индексирования:**  
```python
{имя_последовательности}[индекс]
```

Индексирование доступно для:  
- **Строк:** последовательности символов.  
- **Списков:** последовательности элементов любых типов.  
- **Кортежей:** неизменяемых последовательностей элементов.  


#### **Индексирование строк**  
Строки в Python — это последовательности символов, где каждому символу соответствует порядковый номер, называемый индексом. Индексация позволяет обращаться к символам строки.

```python
s = "Python"

# Положительные индексы
print(s[0])  # 'P' — первый символ
print(s[3])  # 'h' — четвертый символ

# Отрицательные индексы
print(s[-1])  # 'n' — последний символ
print(s[-3])  # 'h' — третий символ с конца
```

Если попытаться обратиться к индексу, выходящему за пределы строки, Python вызовет ошибку:
```python
print(s[10])  # IndexError: string index out of range
```

---

#### **Индексирование списков**  
Списки также поддерживают индексацию, позволяя обращаться к элементам по их порядковому номеру.  
- Индексация работает аналогично строкам.  
- Элементы могут быть любого типа, включая другие списки.  

**Пример работы с индексами в списках:**
```python
lst = [10, 20, 30, 40, 50]

# Положительные индексы
print(lst[0])  # 10 — первый элемент
print(lst[3])  # 40 — четвертый элемент

# Отрицательные индексы
print(lst[-1])  # 50 — последний элемент
print(lst[-3])  # 30 — третий элемент с конца
```

Для вложенных списков индексация может быть многоуровневой:
```python
nested_lst = [1, [2, 3, 4], 5]
print(nested_lst[1])  # [2, 3, 4] — второй элемент (вложенный список)
print(nested_lst[1][2])  # 4 — третий элемент вложенного списка
```

Как и со строками, попытка обратиться к несуществующему индексу вызовет ошибку:
```python
print(lst[10])  # IndexError: list index out of range
```

--- 

### 2. Изменяемость и неизменяемость в Python

**Изменяемость (mutability)** и **неизменяемость (immutability)** — это свойства объектов, определяющие, можно ли изменять их содержимое после создания.



#### **Изменяемые объекты (mutable)**  
Изменяемые объекты — это объекты, которые можно модифицировать после создания. Это означает, что их содержимое (данные) может изменяться без изменения ссылки на объект.  

Примеры изменяемых объектов:
- **Списки (`list`)**
- **Множества (`set`)**
- **Словари (`dict`)**

Пример работы с изменяемыми объектами:
```python
lst = [1, 2, 3]
lst[0] = 10  # Изменяем первый элемент
print(lst)  # [10, 2, 3]

# Добавление нового элемента
lst.append(4)
print(lst)  # [10, 2, 3, 4]
```

---

#### **Неизменяемые объекты (immutable)**  
Неизменяемые объекты — это объекты, которые нельзя изменить после создания. Любая попытка изменения создаёт новый объект в памяти.  

Примеры неизменяемых объектов:
- **Числа (`int`, `float`, `complex`)**
- **Строки (`str`)**
- **Кортежи (`tuple`)**
- **Замороженные множества (`frozenset`)**

Пример работы с неизменяемыми объектами:
```python
s = "hello"
# s[0] = "H"  # Ошибка! Нельзя изменить символ строки

# При модификации строки создаётся новая строка
s = s.upper()
print(s)  # "HELLO"
```

---

#### **Разница между изменяемыми и неизменяемыми объектами**  

| Свойство                | Изменяемые объекты         | Неизменяемые объекты         |
|-------------------------|---------------------------|------------------------------|
| Возможность изменения   | Можно изменять содержимое | Нельзя изменять содержимое   |
| Использование памяти    | Изменения происходят в том же объекте | Создаётся новый объект       |
| Примеры                 | `list`, `dict`, `set`     | `int`, `str`, `tuple`, `frozenset` |

---

#### **Почему это важно?**  
- **Неизменяемые объекты** обеспечивают стабильность данных. Они особенно полезны в многопоточных приложениях, где важно избегать неожиданных изменений.  
- **Изменяемые объекты** удобны для работы с большими наборами данных, когда требуется изменять содержимое.  

Понимание изменяемости помогает избежать ошибок, связанных с непреднамеренными изменениями данных в Python.

---
### 3. **Срезы (slicing)**
Позволяют извлекать подстроки или подсписки из строки, списка или другого индексируемого объекта.

Синтаксис:

```python
sequence[start:end:step]
```

- `start`: индекс начала среза (включительно).
- `end`: индекс конца среза (не включительно).
- `step`: шаг, с которым берутся элементы.

Примеры:

```python
s = "Hello, World!"
print(s[0:5])  # "Hello" — с 0 по 4 индекс
print(s[7:])   # "World!" — с 7 до конца
print(s[:5])   # "Hello" — с начала до 4 индекса
print(s[::2])  # "Hoo ol!" — каждый второй символ
```

Также можно использовать отрицательные индексы для отсчета с конца:

```python
print(s[-6:-1])  # "World" — с конца, с 6 по 1 индексы
```
---
### 4. Строки (`str`) 
Строки в Python представляют собой неизменяемую последовательность символов. Они часто используются для работы с текстовыми данными.

#### Основные свойства строк:  
- Неизменяемы (нельзя изменить символ в строке).
- Поддерживают индексацию и срезы.
- Могут содержать любые символы, включая пробелы и специальные знаки.

#### Создание строк:
```python
s1 = "Привет, мир!"  # Двойные кавычки
s2 = 'Python — мощный язык'  # Одинарные кавычки
s3 = """Многострочная
строка"""  # Тройные кавычки
```

#### Методы строк:
У строк  имеются различные методы, которые помогают нам работать с ними. Не имеет смысла заучивать наизусть все методы. Но если вы столкнулись с задачей, в которой необходимо поработать со строками, сначала обязательно проверьте, возможно, уже есть метод, который вам поможет:

- **Изменение регистра:**  
  ```python
  s = "Python"
  print(s.upper())  # "PYTHON"
  print(s.lower())  # "python"
  ```

- **Удаление символов:**\
`strip([chars])` - удаляет из начала и конца строки указанные символы. Если символы не указаны, удаляются все пробельные символы:
  ```python
  s = "  Hello, world!  "
  print(s.strip())  # "Hello, world!"
  ```

- **Проверки:**  
  ```python
  s = "123"
  print(s.isdigit())  # True
  print(s.isalpha())  # False
  ```

- **Разделение и объединение:**  
`split([separator[, maxsplit]])` - разбивает строку на список подстрок, разделенных разделителем `separator`. Необязательный параметр `maxsplit` задает максимальное количество разбиений.\
`join(iterable)` - объединяет список строк в одну строку, разделяя их указанным разделителем.
  ```python
  s = "one,two,three"
  print(s.split(","))  # ['one', 'two', 'three']
  print("-".join(['one', 'two', 'three']))  # "one-two-three"
  ```

- **Поиск и замена:**  
`replace(old, new[, count])` - заменяет все вхождения одной подстроки на другую. Необязательный параметр `count` задает максимальное количество замен:
  ```python
  s = "Python programming"
  print(s.find("prog"))  # 7
  print(s.replace("Python", "C++"))  # "C++ programming"
  ```
- **Подсчет числа вхождений:**  
`count(substring[, start[, end]])` - возвращает количество вхождений подстроки в строку. Необязательные параметры `start` и `end` задают диапазон поиска:

```python
string = "brown fox jumps over a lazy dog"
count = string.count("o")
print(count)  # 4
```

- **Получение длины строки:**  
`len(string)` - возвращает количество символов в строке:

```python
s = "Hello, World!"
print(len(s))  # 13
```

- **Удаление элементов из строки:**  
`del` - используется для удаления элементов из коллекций, но не применяется напрямую к строкам, так как строки неизменяемы. Однако для удаления символов из строки можно использовать срезы:

```python
s = "Hello, World!"
s = s[:5] + s[7:]  # Удаляем символы с индекса 5 до 7
print(s)  # "Hello World!"
```
- **Функция `print()`** используется для вывода данных на экран или в файл.\
Синтаксис:

```python
print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)
```

- `*objects`: объекты для вывода.
- `sep=' '`: разделитель между объектами (по умолчанию пробел).
- `end='\n'`: символ в конце строки (по умолчанию новый строка).
- `file`: файл для вывода (по умолчанию `sys.stdout` — экран).
- `flush=False`: если True, поток очищается.

Пример:
```python
print(1, 2, 3, 4)  # Выводит: 1 2 3 4
print(1, 2, 3, 4, sep=' - ')  # Выводит: 1 - 2 - 3 - 4
print(1, 2, 3, 4, sep=' - ', end='!')  # Выводит: 1 - 2 - 3 - 4!
```
- **Функция `input()`** позволяет получать данные от пользователя. Результат всегда строка.

Пример:

```python
name = input('Enter your name: ')
print("Your name is", name)

nmbr = input('Enter a number: ')
print(int(nmbr) + 5)  # Преобразуем строку в число
```
- **Повторение строки** в Python осуществляется с помощью оператора умножения (`*`), который позволяет повторить строку заданное количество раз.

Пример:

```python
s = "Hello"
repeated = s * 3
print(repeated)  # "HelloHelloHello"
```

Здесь строка `"Hello"` повторяется 3 раза.

Можно использовать отрицательные числа, но в таком случае результат будет пустой строкой:

```python
s = "Hello"
repeated = s * -2
print(repeated)  # ""
```

Если умножить строку на ноль, результат будет пустая строка:

```python
s = "Hello"
repeated = s * 0
print(repeated)  # ""
```

- **Проверка наличия подстроки в строке:**  
`if substring in string` - проверяет, содержится ли подстрока в строке. Возвращает `True`, если подстрока найдена, и `False` в противном случае:

```python
s = "Python programming"
if "Python" in s:
    print("Подстрока найдена")
else:
    print("Подстрока не найдена")
```

Также, при использовании `if substring in string` можно сразу выполнить действия, если подстрока присутствует:

```python
s = "The quick brown fox"
if "quick" in s:
    print("Подстрока 'quick' найдена!")
```
### Форматирование строк в Python

В Python существует несколько способов форматирования строк:

#### **1. F-строки (Python 3.6+)**

F-строки позволяют вставлять значения переменных или выражений прямо в строку, предваряя её буквой "f" и заключая выражения в фигурные скобки `{}`:

```python
name = "Alice"
age = 25
print(f"My name is {name} and I am {age} years old")
```
Результат:
```
My name is Alice and I am 25 years old
```

Выражения также можно вставлять:
```python
x = 5
print(f"The value of x squared is {x**2}")
```
Результат:
```
The value of x squared is 25
```

#### **2. Оператор %**

Метод, похожий на C, используется реже, но всё ещё встречается в старых проектах:

```python
name = "Alice"
age = 25
print("My name is %s and I am %d years old" % (name, age))
```
Результат:
```
My name is Alice and I am 25 years old
```

#### **3. Метод `format()`**

Метод `format()` позволяет заменять placeholders в строке на переданные значения:

```python
name = "Алексей"
age = 30
print("Меня зовут {}. Мне {} лет.".format(name, age))
```
Результат:
```
Меня зовут Алексей. Мне 30 лет.
```

Также можно использовать индексы и именованные аргументы:

```python
print("Мне {1} лет. Меня зовут {0}.".format(name, age))
print("Меня зовут {name}. Мне {age} лет.".format(name='Алексей', age=30))
```

F-строки предпочтительнее, так как они более читаемы и удобны.


#### Срезы:
```python
s = "Python"
print(s[0])  # "P"
print(s[-1])  # "n"
print(s[1:4])  # "yth"
```

---
## Что такое коллекции в Python?
Коллекции — это контейнеры, которые используются для хранения множества данных. В Python коллекциями являются структуры данных, которые позволяют хранить несколько элементов, упрощая работу с группами данных. Коллекции могут быть изменяемыми (mutable) или неизменяемыми (immutable), и каждый тип коллекции обладает своими особенностями.
В Python есть четыре типа данных, называемых коллекциями:

1. **Список (list)** — упорядоченная и изменяемая коллекция данных. Может содержать дубликаты элементов.
   
   Пример:
   ```python
   lst = [1, 2, 3, 2, 4]
   ```
2. **Множество (set)** — неупорядоченная, неизменяемая коллекция (элементы неизменяемы, но можно добавлять и удалять). Не содержит повторяющихся элементов.
   
   Пример:
   ```python
   st = {1, 2, 3, 4}
   ```

3. **Кортеж (tuple)** — упорядоченная и неизменяемая коллекция данных. Также позволяет дублировать элементы.
   
   Пример:
   ```python
   tpl = (1, 2, 3, 2, 4)
   ```

4. **Словарь (dict)** — упорядоченная (с Python 3.7) и изменяемая коллекция, хранящая пары "ключ-значение". Ключи не могут повторяться.
   
   Пример:
   ```python
   d = {"name": "Alice", "age": 25}
   ```
# Остановимся более подробно на каждой :)

---
### 1. **Списки (`list`)**  
Списки в Python представляют собой изменяемые последовательности объектов.

#### Основные свойства списков:  
- Могут содержать объекты разных типов.  
- Динамическая длина.  
- Поддерживают вложенность.  

#### Создание списков:
```python
lst1 = [1, 2, 3, 4]
lst2 = ["a", "b", "c"]
lst3 = [1, "Python", [2, 3, 4]]  # Вложенный список
lst4 = list() # пустой список
```

#### Основные операции:
- **Добавление элементов:**  
  ```python
  lst = [1, 2, 3]
  lst.append(4)  # Добавляет элементы в конец списка: [1, 2, 3, 4]
  lst.insert(1, 10)  # Добавляет элементы на указанную позицию(первый параметр функции): [1, 10, 2, 3, 4]
  ```

- **Удаление элементов:**  
  ```python
  lst = [1, 2, 3, 4]
  lst.pop()  # Удаляет последний элемент: [1, 2, 3]
  lst.remove(2)  # Удаляет первый найденный элемент: [1, 3]
  my_list.clear() # Удаляет все элементы из списка: [] 
  ```

- **Объединение и повторение:**  
  ```python
  lst1 = [1, 2]
  lst2 = [3, 4]
  print(lst1 + lst2)  # [1, 2, 3, 4]
  print(lst1 * 2)  # [1, 2, 1, 2]
  ```

- **Сортировка:**  
  ```python
  lst = [3, 1, 4, 2]
  lst.sort()  # [1, 2, 3, 4]
  lst.reverse()  # [4, 3, 2, 1]
  # тоже самое что и reverse
  lst.sort(reverse=True) # [4, 3, 2, 1]
  ```
- **Возвращает копию списка:**  
```python
my_list = [1, 2, 3]
new_list = my_list.copy()
print(new_list)  # [1, 2, 3]
```
- **Возвращает количество вхождений элемента в список:**  
```python
my_list = [1, 2, 2, 3, 2]
count = my_list.count(2)
print(count)  # 3

```
- **Добавляет элементы другого итерируемого объекта в конец списка:**  
```python
my_list = [1, 2, 2, 3, 2]
index = my_list.index(2, 2, 5)
print(index)  # 2
```
- **Возвращает индекс первого элемента, равного item, в указанном диапазоне:**  
```python
my_list = [1, 2, 3]
my_list.extend([4, 5])
print(my_list)  # [1, 2, 3, 4, 5]
```
- **Применение заданной функции к каждому элементу:**
`map()` — применяет заданную функцию к каждому элементу итерируемого объекта (список, строка, и т.д.), возвращая итератор. Часто используется для преобразования элементов в последовательности:

   ```python
   my_list = [1, 2, 3, 4, 5]
   result = map(lambda x: x ** 2, my_list)
   print(list(result))  # [1, 4, 9, 16, 25]

   # Преобразование строк в числа
   my_str_list = ['1', '2', '3']
   result = map(int, my_str_list)
   print(list(result))  # [1, 2, 3]
   ```
 Функция `map()` применяет функцию (в примере `lambda x: x ** 2`) к каждому элементу в `my_list`, создавая новый итерируемый объект с результатами.
#### Срезы:
```python
lst = [0, 1, 2, 3, 4]
print(lst[:3])  # [0, 1, 2]
print(lst[1::2])  # [1, 3]
```

---

### 3. **Множества (`set`)**  
Множества в Python представляют собой коллекции уникальных элементов, которые не имеют фиксированного порядка.

#### Основные свойства множеств:  
- Элементы уникальны.  
- Неизменяемые типы данных (строки, числа, кортежи) могут быть элементами множества.  
- Поддерживаются математические операции: объединение, пересечение, разность.

#### Создание множеств:
```python
set1 = {1, 2, 3, 4}
set2 = set([1, 2, 2, 3])  # {1, 2, 3}
set3 = set()  # Пустое множество
```
В Python, значения `True` и `1` (аналогично `False` и `0`) считаются эквивалентными при работе с множествами, так как множества не могут содержать дублирующиеся элементы. Когда вы добавляете в множество такие значения, интерпретатор воспринимает их как одинаковые и оставляет только одно из них.

Рассмотрим пример:

```python
my_set = {0, "tulip", "rose", "iris", True, 1, 77, False, True}
print(my_set, len(my_set))
```

Результат будет следующим:

```
{0, 'rose', 'iris', True, 'tulip', 77} 5
```

- В множестве `my_set` были представлены как `True`, так и `1`, но интерпретатор оставил только одно из них, так как они считаются одинаковыми.
- Также `False` и `0` тоже считаются эквивалентными, и в множестве остался только `0`.
- Дубликаты элементов `True` и `1` были удалены.

Таким образом, множества не допускают дублирования элементов, и даже если два элемента равны по значению (например, `True` и `1`), интерпретатор сохранит только один из них.
Основное преимущество использования множеств, по сравнению
со списками, это использование специального,
оптимизированного метода проверки если какой-то элемент
принадлежит или нет множеству
#### Основные операции:
- **Добавление и удаление элементов:**  
  ```python
  s = {1, 2, 3}
  s.add(4)  # {1, 2, 3, 4}
  s.discard(2)  #  удаляет элемент, если он присутствует, иначе ничего не происходит: {1, 3, 4}
  s.remove(3) #  удаляет элемент, если он присутствует, иначе вызывает ошибку KeyError {1, 4}
  s.remove(5)  # Ошибка KeyError
  s.clear()  # {}
  ```
- **Удаляет случайный элемент:**  
Метод **`pop()`** удаляет случайный элемент из множества и возвращает его. Это полезно, когда нужно удалить элемент, но вы не заинтересованы в его конкретном значении, или хотите просто забрать элемент и работать с ним. Если множество пустое, то метод вызывает ошибку `KeyError`.

Пример использования метода **`pop()`**:

```python
my_set = {1, 2, 3, 4, 5}
removed_item = my_set.pop()
print(f"Удаленный элемент: {removed_item}") # Удаленный элемент: 1
print(f"Множество после удаления элемента: {my_set}") # Множество после удаления элемента: {2, 3, 4, 5}
```

**Примечание:** Поскольку множества в Python неупорядочены, **`pop()`** удаляет случайный элемент, и каждый раз результат может быть разным.


- **Объединение и пересечение:**  
  ```python
  s1 = {1, 2, 3}
  s2 = {3, 4, 5}
  print(s1 | s2)  # {1, 2, 3, 4, 5} (объединение)
  c = a.union(b) # {1, 2, 3, 4, 5} (объединение)
  print(s1 & s2)  # {3} (пересечение)
  intersection_set = s1.intersection(s2 # {3} (пересечение)
  ```

- **Разность и симметричная разность:**  
  ```python
  print(s1 - s2)  # {1, 2} (разность)
  diff_s1_s2 = s1.difference(s2) # {1, 2}
  print(s1 ^ s2)  # {1, 2, 4, 5} (симметричная разность)
  ```
- **Возвращает копию множества:**  
```python
fruits = {"apple", "banana", "cherry"}
new_fruits = fruits.copy()
print(new_fruits)  # {'banana', 'cherry', 'apple'}
```
- **Проверяет, не имеют ли два множества общих элементов:**  
```python
set1 = {1, 2, 3}
set2 = {4, 5, 6}
disjoint_sets = set1.isdisjoint(set2)
print(disjoint_sets)  # True
```
- **Проверяет, является ли одно множество подмножеством другого:**  
```python
set1 = {1, 2, 3, 4, 5}
set2 = {1, 2, 3}
result = set2.issubset(set1)
print(result)  # True
```
#### Проверки:
```python
s = {1, 2, 3}
print(2 in s)  # True
print(5 in s)  # False
```

---

**FROZENSET** — это встроенный тип данных в Python, представляющий неизменяемое множество. В отличие от обычных множеств (`set`), элементы **`frozenset`** нельзя изменять после его создания. Он поддерживает все методы множества, за исключением тех, которые изменяют его (например, `add()`, `remove()` и т. д.).

### Особенности:
- Неизменяемость (неподвластен изменениям после создания).
- Поддерживает операции с множествами, такие как объединение, пересечение, разность и т. д.
- Может быть использован в качестве ключа для словарей, в отличие от обычных множеств.

### Пример использования:

```python
# Создание frozenset
frozen_set = frozenset([1, 2, 3, 4, 5])
print(frozen_set)  # выведет frozenset({1, 2, 3, 4, 5})

# Попытка изменить frozenset вызовет ошибку
# frozen_set.add(6)  # Ошибка: 'frozenset' object has no attribute 'add'

# Можно использовать frozenset в качестве ключа в словаре
my_dict = {frozen_set: "This is a frozen set"}
print(my_dict)
```

### Основные методы **frozenset**:
- **union()**: объединение множеств.
- **intersection()**: пересечение множеств.
- **difference()**: разность множеств.
- **issubset()**: проверка, является ли множество подмножеством.
- **issuperset()**: проверка, является ли множество надмножеством.

### Пример работы с методами:

```python
fs1 = frozenset([1, 2, 3])
fs2 = frozenset([3, 4, 5])

print(fs1.union(fs2))        # frozenset({1, 2, 3, 4, 5})
print(fs1.intersection(fs2)) # frozenset({3})
print(fs1.difference(fs2))   # frozenset({1, 2})
```

**frozenset** полезен, когда вам нужно использовать неизменяемые коллекции элементов, например, в качестве ключей словаря или для безопасной передачи данных в многозадачных приложениях.

### Полезные функции
Также давайте посмотрим на различные функции, которые помогают нам работать со списками и множествами:

1. **`len()`** — возвращает количество элементов в последовательности (списке, множестве и т.д.):
   ```python
   my_list = [1, 2, 3, 4, 5]
   print(len(my_list))  # 5

   my_set = {1, 1, 2, 2}
   print(len(my_set))  # 2
   ```

2. **`max()`** — возвращает максимальное значение из последовательности:
   ```python
   my_list = [5, 2, 8, 1, 9]
   print(max(my_list))  # 9

   my_set = {5, 2, 8, 1, 9}
   print(max(my_set))  # 9
   ```

3. **`min()`** — возвращает минимальное значение из последовательности:
   ```python
   my_list = [5, 2, 8, 1, 9]
   print(min(my_list))  # 1

   my_set = {5, 2, 8, 1, 9}
   print(min(my_set))  # 1
   ```

4. **`sorted()`** — сортирует последовательность и возвращает новый отсортированный список. Можно использовать параметр `reverse=True` для сортировки по убыванию:
   ```python
   my_list = [5, 2, 8, 1, 9]
   sorted_list = sorted(my_list)
   print(sorted_list)  # [1, 2, 5, 8, 9]

   sorted_list_descending = sorted(my_list, reverse=True)
   print(sorted_list_descending)  # [9, 8, 5, 2, 1]
   ```

   Когда сортируешь множество, результатом будет список:
   ```python
   my_set = {1, 1, 2, 2}
   print(sorted(my_set))  # [1, 2]
   ```
   Вот дополнительные полезные функции:

5. **`sum()`** — возвращает сумму всех элементов в последовательности. Работает с числами:

   ```python
   my_list = [1, 2, 3, 4, 5]
   print(sum(my_list))  # 15

   my_set = {1, 2, 3, 4, 5}
   print(sum(my_set))  # 15
   ```


### Итог: Сравнение строк, списков и множеств  
| Свойство        | Строки (`str`)    | Списки (`list`) | Множества (`set`) |
|------------------|------------------|------------------|-------------------|
| Изменяемость    | Нет              | Да               | Да               |
| Уникальность    | Нет              | Нет              | Да               |
| Индексация      | Да               | Да               | Нет              |
| Поддержка срезов| Да               | Да               | Нет              |
| Использование   | Текстовые данные | Любые данные     | Уникальные данные|

Эти структуры данных покрывают широкий спектр задач, предоставляя инструменты для работы с текстами, последовательностями и коллекциями уникальных элементов.