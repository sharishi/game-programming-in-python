### **Функции в Python**

Функции — это важный концепт в программировании, которые позволяют организовать код, повысить его читаемость, уменьшить дублирование и сделать программу более гибкой. Рассмотрим основные особенности и преимущества использования функций в Python:

### Основные особенности функций:
1. **Блок кода, который выполняет задачу**: 
   Функция представляет собой блок кода, который выполняет определенную задачу. Этот код запускается только при вызове функции.

2. **Разбиение программы на части**:
   Функции помогают разделить большую программу на более мелкие и понятные части. Каждый блок выполняет отдельную задачу, что делает программу легче для понимания и поддержки.

3. **Избежание повторений**:
   Использование функций позволяет избежать повторения одного и того же кода. Вместо того чтобы писать одни и те же операции несколько раз, можно просто вызвать функцию в нужный момент.

4. **Передача данных**:
   В функции можно передавать данные, которые она будет использовать. Эти данные называются **параметры** или **аргументы**. Таким образом, функция может работать с различными входными значениями.

5. **Возврат значений**:
   Функция может возвращать значение или результат своей работы с помощью оператора `return`. Это позволяет функции вычислять что-то и передавать результат обратно в программу.

### Преимущества использования функций:
- **Читаемость и организация**: Функции позволяют разбить код на логические части, что улучшает структуру программы.
- **Многократное использование**: Функции позволяют использовать один и тот же код в разных частях программы, что уменьшает дублирование.
- **Управляемость**: Большие проекты проще поддерживать и обновлять, если они структурированы с помощью функций.

### **1. Создание функций**
Создание функций:
- В Python функции создаются с использованием ключевого слова `def`, за которым следует имя функции, список параметров (если они есть), двоеточие и тело функции.\

Возвращение значения:
- Используйте ключевое слово return для возврата значения из функции. Если в функции нет оператора return, она все равно завершит свое выполнение, но вернет значение None по умолчанию.
**Синтаксис:**
```python
def function_name(parameters):
    # Тело функции
    # Операции, которые нужно выполнить
    return value  # (необязательно)
```

Пример функции, которая принимает два параметра и возвращает их сумму:

```python
def add_numbers(a, b):
    return a + b

result = add_numbers(5, 3)
print(result)  # Выведет: 8
```
### Резервированное слово `pass` в Python

- `pass` используется для определения нулевой декларации (NULL).
- В отличие от комментариев, которые интерпретатор игнорирует, `pass` не игнорируется.
- Инструкция `pass` может быть использована как резервная конструкция, когда программист не знает, какой код нужно написать для функции или класса.
- Также `pass` используется, чтобы "оставить" функцию или блок кода пустым, не вызывая ошибок.


**Пример**:
```python
def nullFunction():
    pass

nullFunction()  # функция ничего не делает
```
### **2. Аргументы и параметры функции**

- **Параметры** — это переменные, которые определяются в объявлении функции. Они представляют данные, которые функция может использовать в своем теле.
- **Аргументы** — это фактические значения, которые передаются функции при ее вызове.

Функции могут иметь разные типы параметров:

#### **2.1. Позиционные аргументы**

Это самые простые аргументы, которые передаются в функцию в определенном порядке.

Пример:
```python
def greet(name, age):
    print(f"Hello, {name}. You are {age} years old.")

greet("Alice", 25)  # Позиционные аргументы
```

#### **2.2. Именованные аргументы**

При использовании именованных аргументов порядок, в котором они передаются, не имеет значения. Вместо этого можно явно указать имя параметра.

Пример:
```python
def greet(name, age):
    print(f"Hello, {name}. You are {age} years old.")

greet(age=25, name="Alice")  # Именованные аргументы
```

#### **2.3. Аргументы с умолчанием**

Функции могут иметь значения по умолчанию для некоторых параметров. Если аргумент не передан при вызове функции, будет использовано значение по умолчанию.

Пример:
```python
def greet(name, age=18):
    print(f"Hello, {name}. You are {age} years old.")

greet("Alice")  # Используется значение по умолчанию для age
```

#### **2.4. Переменное количество аргументов**

Используя `*args`, можно передавать переменное количество позиционных аргументов. Это позволяет функции принимать любое количество аргументов.
Таким образом, функция получит кортеж аргументов и сможет соответственно обращаться к элементам
Пример:
```python
def add_numbers(*args):
    return sum(args)

print(add_numbers(1, 2, 3))  # 6
print(add_numbers(4, 5, 6, 7, 8))  # 30
```

Используя `**kwargs`, можно передавать переменное количество именованных аргументов.\
Таким образом, функция получит словарь аргументов и сможет соответственно обращаться к элементам:\
Пример:
```python
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Alice", age=25)  # Выведет: name: Alice, age: 25
```

### **3. Возврат значений**

Функции могут возвращать результат с помощью оператора `return`. Возврат значения завершает выполнение функции и передает результат в место вызова.

Пример:
```python
def square(x):
    return x ** 2

result = square(4)
print(result)  # 16
```

Если функция не возвращает явно никакого значения, Python автоматически возвращает `None`.

Пример:
```python
def greet(name):
    print(f"Hello, {name}")

result = greet("Alice")
print(result)  # None
```

### **4. Лямбда-функции**

Лямбда-функции — это небольшие анонимные функции, которые определяются с помощью ключевого слова `lambda`. Они обычно используются для одноразовых операций, таких как сортировка или фильтрация.

Синтаксис:
```python
lambda arguments: expression
```

Пример:
```python
square = lambda x: x ** 2
print(square(5))  # 25
```

- Лямбда-функция может принимать любое количество аргументов, но может содержать только одно выражение. Это выражение вычисляется, и результат автоматически возвращается.
- Лямбда-функции не требуют явного указания команды `return`, так как результат выражения возвращается по умолчанию.
- Лямбда-выражения часто используются в функциональном программировании.


**Пример**:
```python
# Лямбда-функция внутри функции map
numbers = [1, 2, 3, 4]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)  # [1, 4, 9, 16]
```
Лямбда-функции полезны, когда нужно быстро определить небольшую функцию, например, для использования в `map()`, `filter()`, или `sorted()`.
#### Пример использования функции `sorted()` с лямбда-выражением в качестве параметра

Функция `sorted()` используется для сортировки итерируемых объектов. Она возвращает отсортированный список, не изменяя оригинальный объект. При этом можно указать порядок сортировки (по возрастанию или убыванию), а также применить свою логику сортировки через параметр `key`.

**Синтаксис**:
```python
sorted(iterable, key=key, reverse=reverse)
```
- **iterable** — обязательный параметр, объект, который нужно отсортировать.
- **key** — необязательный параметр, функция, которая определяет порядок сортировки.
- **reverse** — необязательный параметр, если установлен в `True`, сортировка будет происходить в обратном порядке.

### Пример:
```python
names = ['Alice', 'Jhon', 'Annie', 'David', 'Eve', 'Jhonny', 'Mary']

# Сортировка по длине строк
sorted_names = sorted(names, key=lambda x: len(x))
print(sorted_names)
```

**Результат**:
```
['Eve', 'Mary', 'Annie', 'Jhon', 'Alice', 'David', 'Jhonny']
```

Здесь используется лямбда-функция `lambda x: len(x)`, которая позволяет отсортировать список строк по длине каждого элемента.
### **5. Вложенные функции**

В Python функции могут быть вложенными, то есть одна функция может быть определена внутри другой. Вложенные функции могут использовать переменные из внешней функции, что позволяет создавать замыкания.

Пример:
```python
def outer_function(x):
    def inner_function(y):
        return y * 2
    return inner_function(x)

result = outer_function(5)
print(result)  # 10
```
### 6. Пространства имен
**Пространство имен** - это используемая коллекция имен. В Python можно представить
пространство имен как отображение каждого определенного имени на соответствующие
объекты
- Различные пространства имен могут сосуществовать в определенный момент времени, но
они полностью изолированы
- Пространство имен, содержащее все встроенные имена, создается при запуске
интерпретатора Python и существует до тех пор, пока мы не завершим работу
 Это причина того, что встроенные функции, такие как id() (позволяет получить адрес в
оперативной памяти какого-либо объекта), print() и т. д. всегда доступны для нас из любой
части программы. Каждый модуль создает свое собственное глобальное пространство имен
- Эти разные пространства имен изолированы. Следовательно, одно и то же имя, которое
может существовать в разных модулях, не конфликтует
- Модули могут содержать различные функции и классы. При вызове функции, создается
локальное пространство имен, в котором определены все имена используемые в теле
функции. Аналогично, дела обстоят и с классом
- 
### **7. Область видимости (Scope)**
**Область действия (или видимости)** - это часть программы, из которой
можно напрямую получить доступ к пространству имен без какого-либо
префикса(то есть переменная распознается)

В Python существует несколько уровней области видимости:
- **Локальная область видимости** — переменные, определенные внутри функции.
- **Область видимости функции** — переменные, определенные в функции, но доступные и для вложенных функций.
- **Глобальная область видимости** — переменные, определенные вне всех функций, доступные в любом месте программы.
- **Область видимости встроенных функций** — стандартные функции Python, такие как `print()`.\
Когда ссылка делается внутри функции, имя ищется в локальном
пространстве имен, затем в глобальном пространстве имен и, наконец,
во встроенном пространстве имен
Пример:
```python
x = 10  # Глобальная переменная

def my_function():
    x = 5  # Локальная переменная
    print(x)

my_function()  # Выведет: 5
print(x)  # Выведет: 10
```


 Чтобы сделать переменную видимой и доступной на **глобальном уровне**, используется ключевое слово `global`.

#### Особенности:
1. **Локальная переменная**:
   - Доступна только внутри функции.
   - Уничтожается после завершения выполнения функции.
2. **Ключевое слово `global`**:
   - Делает переменную глобальной, даже если она создается внутри функции.
   - Позволяет изменить глобальную переменную внутри функции.



#### Пример:
```python
def my_phone():
    global phone  # Делаем переменную глобальной
    phone = "78997788"
    return phone

phone = "69777777"  # Глобальная переменная
print("Global phone number is", phone)  # Выведет: 69777777
print("My phone number is --> " + my_phone())  # Выведет: 78997788
print("Updated global phone number is", phone)  # Выведет: 78997788
```

**Вывод**:
```
Global phone number is 69777777
My phone number is --> 78997788
Updated global phone number is 78997788
```

#### Пример изменения глобальной переменной:
```python
x = 10  # Глобальная переменная

def update_global():
    global x
    x += 5  # Изменяем значение глобальной переменной
    print("Inside function:", x)

update_global()  # Выведет: Inside function: 15
print("Outside function:", x)  # Выведет: Outside function: 15
```



#### Когда использовать `global`:
- При необходимости изменения глобальной переменной внутри функции.
- Если переменная должна быть доступна как внутри функции, так и вне её.



#### Важно:
- Использование `global` следует минимизировать для сохранения читаемости и предсказуемости кода. Вместо этого лучше передавать переменные как параметры функции и возвращать их значения.
- Время жизни переменной - это период, в течение
которого переменная находится в памяти. Время
жизни переменных внутри функции равно времени
ее выполнения
- Они уничтожаются, как только мы возвращаемся из
функции (за исключением, когда используется
ключевое слово global). Следовательно, функция не
запоминает значение
предыдущих вызовов
---
### **8. Рекурсия**

Рекурсия — это когда функция вызывает сама себя. Рекурсия часто используется для решения задач, которые могут быть разбиты на подзадачи того же типа, например, в поиске и сортировке данных.

Пример вычисления факториала:
```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(5))  # 120
```

### **9. Докстринги (docstrings)**

Докстринги — это строки, которые размещаются сразу после объявления функции, чтобы описать ее поведение. Они помогают улучшить читаемость и поддерживаемость кода.

Пример:
```python
def greet(name):
    """
    Функция для приветствия пользователя по имени.
    
    :param name: Имя пользователя
    :return: Строка с приветствием
    """
    return f"Hello, {name}!"

print(greet.__doc__)  # Выведет описание функции
```
### 10. Модули в Python

- **Модуль** — это файл, содержащий определения переменных и инструкции Python.  
- Модули помогают организовать код, делая программы более удобными для чтения и поддержки.  
- Имя модуля соответствует имени файла Python и имеет расширение `.py`.  

#### Импорт модулей
Для использования содержимого модуля его нужно **импортировать** с помощью ключевого слова `import`.

#### Пример:
```python
import math
print(math.pi)  # 3.141592653589793
```

После импорта все функции и переменные модуля доступны с использованием синтаксиса `имя_модуля.имя_атрибута`.

### Импорт отдельных атрибутов
Можно импортировать только конкретные элементы модуля с помощью `from ... import`.

#### Пример:
```python
from math import pi
print(pi)  # 3.141592653589793
```

---
### Разделение кода на модули

В больших проектах полезно разделять код на модули для удобства и читаемости.  

#### Пример:
Создаем два файла:  
1. **`module_example5.py`** — содержит функции и данные.  
2. **`example5.py`** — вызывает модуль и использует его.  

---

#### Содержимое файла `module_example5.py`:
```python
# Определение словаря сотрудника
employee = {
    "name": "John",
    "surname": "Smith",
    "age": 18,
    "phone_number": "+37368778899",
    "email": "john@gmail.com"
}

# Функция для составления списка предпочтений
def choice(food):
    result = ""
    for x in food:
        result += "\n" + x
    return result
```

---

#### Содержимое файла `example5.py`:
```python
# Импортируем модуль
import module_example5

# Используем данные и функции из модуля
fruits = ["яблоки", "бананы", "черешня"]
print(
    "Сотрудник {} предпочитает следующие фрукты:".format(
        module_example5.employee["name"]
    ) + module_example5.choice(fruits)
)
```

---

#### Результат выполнения `example5.py`:
```
Сотрудник John предпочитает следующие фрукты:
яблоки
бананы
черешня
```

Это помогает структурировать проект: функции, данные, и бизнес-логика разделены.
### Переименование модулей с использованием `as`

- Переименование модуля при импорте позволяет упростить его использование.  
- Синтаксис:  
  ```python
  import имя_модуля as псевдоним
  ```
- Используется, чтобы сократить или сделать более удобным имя модуля.

#### Пример:
```python
# Импорт модуля с псевдонимом
import module_example5 as m5

# Пример использования
fruits = ["яблоки", "бананы", "черешня"]
print("Сотрудник {} предпочитает следующие фрукты: ".format(m5.employee["name"]) + m5.choice(fruits))
```

В этом примере:  
- Модуль `module_example5` переименован в `m5` для сокращения.  
- Легко обращаться к содержимому модуля через псевдоним, например: `m5.employee["name"]`.
Этот способ позволяет использовать импортированные атрибуты напрямую, без указания имени модуля.
### **Заключение**

Функции — это один из самых мощных инструментов в Python. Они позволяют структурировать код, повторно использовать блоки кода, работать с аргументами и возвращать значения. Использование функций способствует улучшению читаемости и поддерживаемости программ, особенно в крупных проектах.